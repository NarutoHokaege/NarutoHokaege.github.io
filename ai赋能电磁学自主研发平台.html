<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电磁AI课堂 - 完整优化版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
        }
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        /* 导航栏 */
        header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
        }
        .nav-links {
            display: flex;
            gap: 25px;
        }
        .nav-links a {
            color: white;
            text-decoration: none;
            font-size: 16px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        .nav-links a:hover {
            color: #3498db;
            background-color: rgba(255,255,255,0.1);
        }
        /* 公共页面样式 */
        .page {
            padding: 40px 0;
            display: none;
        }
        .page.active {
            display: block;
        }
        .page-title {
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        /* 首页 */
        .banner {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 80px 0;
            text-align: center;
        }
        .banner h1 {
            font-size: 40px;
            margin-bottom: 20px;
        }
        .banner p {
            font-size: 18px;
            max-width: 700px;
            margin: 0 auto 40px;
        }
        .features {
            padding: 60px 0;
        }
        .features h2 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 30px;
            color: #2c3e50;
        }
        .card-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 300px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .card img {
            width: 100%;
            height: 180px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .card h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        /* 概念可视化页面 */
        .concept-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        .concept-controls {
            width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .concept-controls h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .model-type {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .model-type:hover {
            border-color: #3498db;
            background-color: #f0f7ff;
        }
        .model-type.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .concept-visual {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        .concept-visual h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .concept-visual img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
        }
        .concept-explain {
            width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .concept-explain h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        /* AI助教页面 */
        .assistant-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        .chat-box {
            flex: 1;
            min-width: 300px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .chat-messages {
            height: 500px;
            padding: 20px;
            overflow-y: auto;
            border-bottom: 1px solid #eee;
        }
        .message {
            margin-bottom: 15px;
            max-width: 80%;
        }
        .user-message {
            margin-left: auto;
        }
        .message-content {
            padding: 10px 15px;
            border-radius: 10px;
            display: inline-block;
        }
        .user-message .message-content {
            background: #3498db;
            color: white;
        }
        .ai-message .message-content {
            background: #f1f1f1;
        }
        .chat-input {
            padding: 15px;
            display: flex;
            gap: 10px;
        }
        .chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
        }
        .chat-input button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
        }
        /* 虚拟实验页面 */
        .experiment-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        .exp-controls {
            width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .exp-list {
            margin-bottom: 30px;
        }
        .exp-list h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        .exp-item {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .exp-item:hover {
            border-color: #3498db;
            background-color: #f0f7ff;
        }
        .exp-item.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .param-controls {
            margin-top: 20px;
        }
        .param-controls h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        .param-item {
            margin-bottom: 15px;
        }
        .param-item label {
            display: block;
            margin-bottom: 5px;
            color: #555;
        }
        .param-item input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .start-btn {
            width: 100%;
            padding: 10px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        .start-btn:hover {
            background-color: #219653;
        }
        .exp-visual {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .exp-visual h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .exp-model {
            width: 100%;
            height: 400px;
            background-color: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .exp-model img {
            max-width: 100%;
            max-height: 100%;
            padding: 20px;
        }
        .exp-result {
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 8px;
        }
        /* 智能题库页面 */
        .question-filter {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .filter-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .filter-item select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 150px;
        }
        .filter-btn {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .question-list {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .question-item {
            padding: 20px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .question-item:hover {
            background-color: #f8f9fa;
        }
        .question-item.hidden {
            display: none;
        }
        .question-item h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .question-tags {
            margin-bottom: 15px;
        }
        .question-tag {
            display: inline-block;
            padding: 3px 8px;
            background-color: #f0f7ff;
            color: #3498db;
            border-radius: 3px;
            font-size: 12px;
            margin-right: 5px;
        }
        .question-content {
            margin-bottom: 15px;
            line-height: 1.7;
        }
        .question-action {
            text-align: right;
        }
        .view-answer {
            padding: 6px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px 0;
            margin-top: 60px;
        }
        /* 点电荷电场可视化样式 */
        #point-charge-visual {
            width: 100%;
            height: 600px;
            background-color: #0a1128;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        /* 电磁感应实验样式 */
        .induction-experiment {
            width: 100%;
            height: 600px;
            background-color: #f8fafc;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        /* 开关样式 */
        .relative.inline-block.w-12.align-middle.select-none .block,
        .relative.inline-block.w-10.align-middle.select-none .block {
            transition: background-color 0.3s;
        }
        .relative.inline-block.w-12.align-middle.select-none .dot,
        .relative.inline-block.w-10.align-middle.select-none .dot {
            transition: transform 0.3s;
        }
        .relative.inline-block.w-12.align-middle.select-none input:checked + .block,
        .relative.inline-block.w-10.align-middle.select-none input:checked + .block {
            background-color: #3b82f6;
        }
        .relative.inline-block.w-12.align-middle.select-none input:checked + .block + .dot {
            transform: translateX(24px);
        }
        .relative.inline-block.w-10.align-middle.select-none input:checked + .block + .dot {
            transform: translateX(20px);
        }
        /* 电磁感应实验特有样式 */
        .magnetic-field-line {
            stroke: #1E40AF;
            stroke-width: 2;
            fill: none;
        }
        .magnetic-field-line-weak {
            stroke: #1E40AF;
            stroke-width: 1;
            stroke-opacity: 0.6;
            fill: none;
        }
        .electron {
            fill: #FF6B00;
            r: 3;
        }
        .current-indicator {
            stroke: #FF6B00;
            stroke-width: 3;
            fill: none;
        }
        .glass-effect {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .sensor-display {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
        }
        .slider-track {
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
        }
        .slider-thumb {
            width: 20px;
            height: 20px;
            background: #1E40AF;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        .slider-thumb:hover {
            background: #1e3a8a;
        }
        .hidden {
            display: none !important;
        }
    </style>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/geometries/ParametricGeometries.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/materials/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/objects/Line2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/geometries/LineGeometry.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#1a56db',
                        secondary: '#7e3af2',
                        positive: '#0694a2',
                        negative: '#e02424',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .glow {
                filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.5));
            }
            .glow-positive {
                filter: drop-shadow(0 0 8px rgba(6, 148, 162, 0.7));
            }
            .glow-negative {
                filter: drop-shadow(0 0 8px rgba(224, 36, 36, 0.7));
            }
        }
    </style>
</head>
<body>
    <!-- 导航栏 -->
    <header>
        <div class="container nav">
            <div class="logo">电磁AI课堂</div>
            <div class="nav-links">
                <a onclick="showPage('home')">首页</a>
                <a onclick="showPage('concept')">概念可视化</a>
                <a onclick="showPage('assistant')">AI助教</a>
                <a onclick="showPage('experiment')">虚拟实验</a>
                <a onclick="showPage('question')">智能题库</a>
            </div>
        </div>
    </header>
    <!-- 首页 -->
    <div id="home" class="page active">
        <div class="banner">
            <div class="container">
                <h1>AI助力电磁学学习</h1>
                <p>可视化抽象概念 | 虚拟实验操作 | 智能答疑解惑</p>
            </div>
        </div>
        <div class="features">
            <div class="container">
                <h2>核心功能</h2>
                <div class="card-container">
                    <div class="card" onclick="showPage('concept')">
                        <img src="https://img95.699pic.com/xsj/0t/8v/aw.jpg!/fh/300" alt="概念可视化">
                        <h3>概念可视化</h3>
                        <p>3D动态展示电场线、等势面，抽象概念直观化</p>
                    </div>
                    <div class="card" onclick="showPage('assistant')">
                        <img src="https://img95.699pic.com/xsj/0k/4n/uf.jpg!/fh/300" alt="AI助教">
                        <h3>AI学习助教</h3>
                        <p>实时解答问题，分析解题思路，个性化辅导</p>
                    </div>
                    <div class="card" onclick="showPage('experiment')">
                        <img src="https://img95.699pic.com/xsj/0n/51/q6.jpg!/fh/300" alt="虚拟实验">
                        <h3>虚拟电磁实验</h3>
                        <p>调整参数观察粒子运动，安全直观易操作</p>
                    </div>
                    <div class="card" onclick="showPage('question')">
                        <img src="https://img95.699pic.com/xsj/0s/6j/4x.jpg!/fh/300" alt="智能题库">
                        <h3>智能题库</h3>
                        <p>按知识点筛选习题，AI批改+错题分析</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- 概念可视化页面 -->
    <div id="concept" class="page">
        <div class="container">
            <h2 class="page-title">电场与电势可视化</h2>
            <div class="concept-container">
                <div class="concept-controls">
                    <h3>选择物理模型</h3>
                    <div class="model-type active" onclick="changeModel('point')">点电荷产生的电场</div>
                    <div class="model-type" onclick="changeModel('induction')">电磁感应现象</div>
                </div>
                <div class="concept-visual">
                    <h3>3D模型展示</h3>
                    <div id="model-view">
                        <!-- 点电荷电场可视化 -->
                        <div id="point-charge-visual" class="active">
                            <div class="flex h-full">
                                <!-- 左侧：3D可视化区域 - 加宽 -->
                                <div class="w-full md:w-2/3 h-full relative">
                                    <div id="scene-container" class="w-full h-full"></div>
                                    
                                    <!-- 视角控制提示 -->
                                    <div class="absolute bottom-4 left-4 bg-black bg-opacity-50 p-3 rounded-lg text-sm">
                                        <div class="flex items-center mb-2">
                                            <i class="fa fa-mouse-pointer mr-2 text-blue-400"></i>
                                            <span>拖动: 旋转视角</span>
                                        </div>
                                        <div class="flex items-center mb-2">
                                            <i class="fa fa-search mr-2 text-blue-400"></i>
                                            <span>滚轮: 缩放</span>
                                        </div>
                                        <div class="flex items-center">
                                            <i class="fa fa-arrows mr-2 text-blue-400"></i>
                                            <span>Shift+拖动: 平移</span>
                                        </div>
                                    </div>
                                    
                                    <!-- 重置视图按钮 -->
                                    <button id="reset-view" class="absolute top-4 right-4 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg flex items-center transition-all">
                                        <i class="fa fa-refresh mr-2"></i>
                                        <span>重置视图</span>
                                    </button>
                                </div>
                                
                                <!-- 右侧：控制面板 - 加宽 -->
                                <div class="w-full md:w-1/3 h-full bg-gray-800 p-6 overflow-y-auto">
                                    <h1 class="text-2xl font-bold mb-6 text-center text-shadow">点电荷电场线可视化</h1>
                                    
                                    <!-- 预设场景 -->
                                    <div class="mb-8">
                                        <h2 class="text-xl font-semibold mb-4 flex items-center">
                                            <i class="fa fa-bookmark mr-2 text-blue-400"></i>
                                            预设场景
                                        </h2>
                                        <div class="grid grid-cols-1 gap-3">
                                            <button id="preset-single-positive" class="bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition-all flex items-center">
                                                <div class="w-4 h-4 rounded-full bg-positive mr-3 glow-positive"></div>
                                                <span>单个正电荷</span>
                                            </button>
                                            <button id="preset-single-negative" class="bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition-all flex items-center">
                                                <div class="w-4 h-4 rounded-full bg-negative mr-3 glow-negative"></div>
                                                <span>单个负电荷</span>
                                            </button>
                                            <button id="preset-dipole" class="bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition-all flex items-center">
                                                <div class="w-4 h-4 rounded-full bg-positive mr-2 glow-positive"></div>
                                                <div class="w-4 h-4 rounded-full bg-negative mr-3 glow-negative"></div>
                                                <span>等量异种电荷</span>
                                            </button>
                                            <button id="preset-same-charges" class="bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition-all flex items-center">
                                                <div class="w-4 h-4 rounded-full bg-positive mr-2 glow-positive"></div>
                                                <div class="w-4 h-4 rounded-full bg-positive mr-3 glow-positive"></div>
                                                <span>等量同种电荷</span>
                                            </button>
                                            <button id="preset-three-charges" class="bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition-all flex items-center">
                                                <div class="w-4 h-4 rounded-full bg-positive mr-2 glow-positive"></div>
                                                <div class="w-4 h-4 rounded-full bg-negative mr-2 glow-negative"></div>
                                                <div class="w-4 h-4 rounded-full bg-positive mr-3 glow-positive"></div>
                                                <span>三个电荷系统</span>
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- 电荷管理 -->
                                    <div class="mb-8">
                                        <div class="flex justify-between items-center mb-4">
                                            <h2 class="text-xl font-semibold flex items-center">
                                                <i class="fa fa-cog mr-2 text-blue-400"></i>
                                                电荷管理
                                            </h2>
                                            <button id="add-charge" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-full transition-all">
                                                <i class="fa fa-plus"></i>
                                            </button>
                                        </div>
                                        
                                        <div id="charges-container" class="space-y-4">
                                            <!-- 电荷控制项将通过JS动态添加 -->
                                        </div>
                                    </div>
                                    
                                    <!-- 显示选项 -->
                                    <div class="mb-8">
                                        <h2 class="text-xl font-semibold mb-4 flex items-center">
                                            <i class="fa fa-eye mr-2 text-blue-400"></i>
                                            显示选项
                                        </h2>
                                        
                                        <div class="space-y-4">
                                            <div class="flex items-center justify-between">
                                                <label for="show-field-lines" class="text-gray-300">显示电场线</label>
                                                <div class="relative inline-block w-12 align-middle select-none">
                                                    <input type="checkbox" id="show-field-lines" class="sr-only" checked>
                                                    <div class="block h-6 bg-gray-600 rounded-full w-12"></div>
                                                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform translate-x-6"></div>
                                                </div>
                                            </div>
                                            
                                            <div class="flex items-center justify-between">
                                                <label for="show-heatmap" class="text-gray-300">显示电场强度热力图</label>
                                                <div class="relative inline-block w-12 align-middle select-none">
                                                    <input type="checkbox" id="show-heatmap" class="sr-only">
                                                    <div class="block h-6 bg-gray-600 rounded-full w-12"></div>
                                                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform"></div>
                                                </div>
                                            </div>
                                            
                                            <div class="flex items-center justify-between">
                                                <label for="show-vectors" class="text-gray-300">显示电场强度矢量</label>
                                                <div class="relative inline-block w-12 align-middle select-none">
                                                    <input type="checkbox" id="show-vectors" class="sr-only">
                                                    <div class="block h-6 bg-gray-600 rounded-full w-12"></div>
                                                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform"></div>
                                                </div>
                                            </div>
                                            
                                            <div class="flex items-center justify-between">
                                                <label for="show-grid" class="text-gray-300">显示网格</label>
                                                <div class="relative inline-block w-12 align-middle select-none">
                                                    <input type="checkbox" id="show-grid" class="sr-only" checked>
                                                    <div class="block h-6 bg-gray-600 rounded-full w-12"></div>
                                                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform translate-x-6"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- 电场线参数 -->
                                    <div class="mb-8">
                                        <h2 class="text-xl font-semibold mb-4 flex items-center">
                                            <i class="fa fa-sliders mr-2 text-blue-400"></i>
                                            电场线参数
                                        </h2>
                                        
                                        <div class="space-y-4">
                                            <div>
                                                <label for="field-line-density" class="block text-gray-300 mb-2">电场线密度</label>
                                                <input type="range" id="field-line-density" min="8" max="48" value="32" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                                    <span>稀疏</span>
                                                    <span id="density-value">32</span>
                                                    <span>密集</span>
                                                </div>
                                            </div>
                                            
                                            <div>
                                                <label for="field-line-length" class="block text-gray-300 mb-2">电场线长度</label>
                                                <input type="range" id="field-line-length" min="50" max="300" value="200" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                                    <span>短</span>
                                                    <span id="length-value">200</span>
                                                    <span>长</span>
                                                </div>
                                            </div>
                                            
                                            <div>
                                                <label for="field-line-step" class="block text-gray-300 mb-2">电场线步长</label>
                                                <input type="range" id="field-line-step" min="0.01" max="0.1" step="0.01" value="0.03" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                                    <span>精细</span>
                                                    <span id="step-value">0.03</span>
                                                    <span>粗略</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- 物理参数 -->
                                    <div class="mb-8">
                                        <h2 class="text-xl font-semibold mb-4 flex items-center">
                                            <i class="fa fa-flask mr-2 text-blue-400"></i>
                                            物理参数
                                        </h2>
                                        
                                        <div class="space-y-4">
                                            <div>
                                                <label for="coulomb-constant" class="block text-gray-300 mb-2">库仑常数 (k)</label>
                                                <div class="flex items-center">
                                                    <input type="number" id="coulomb-constant" value="8.99" min="0.1" max="100" step="0.01" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                                                    <span class="ml-2 text-gray-400">× 10<sup>9</sup></span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- 关于 -->
                                    <div class="mt-auto pt-6 border-t border-gray-700">
                                        <h2 class="text-xl font-semibold mb-4 flex items-center">
                                            <i class="fa fa-info-circle mr-2 text-blue-400"></i>
                                            关于
                                        </h2>
                                        <p class="text-gray-400 text-sm">
                                            本应用使用Three.js实现点电荷电场线的3D可视化。通过调整电荷的位置、电荷量和类型，可以观察不同情况下的电场分布。
                                        </p>
                                        <p class="text-gray-400 text-sm mt-2">
                                            电场线从正电荷出发，终止于负电荷，其密度表示电场强度。
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- 电磁感应可视化 -->
                        <div id="induction-visual" class="hidden">
                            <div class="induction-experiment">
                                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 h-full">
                                    <!-- 左侧：实验区域 -->
                                    <div class="lg:col-span-2 bg-white rounded-xl shadow-lg overflow-hidden h-full">
                                        <div class="p-4 bg-primary text-white flex justify-between items-center">
                                            <h2 class="text-xl font-semibold">实验区域</h2>
                                            <div class="flex space-x-2">
                                                <button id="playPauseBtn" class="px-3 py-1 bg-white text-primary rounded-md hover:bg-blue-50 transition">
                                                    <i class="fa fa-play mr-1"></i> 播放
                                                </button>
                                                <div class="relative">
                                                    <select id="experimentType" class="appearance-none bg-white text-primary px-3 py-1 pr-8 rounded-md hover:bg-blue-50 transition">
                                                        <option value="basic">基础实验</option>
                                                        <option value="coil-turns">线圈匝数实验</option>
                                                        <option value="magnet-strength">磁铁强度实验</option>
                                                        <option value="microscopic">微观粒子视图</option>
                                                    </select>
                                                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-primary">
                                                        <i class="fa fa-chevron-down text-xs"></i>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="relative h-full">
                                            <canvas id="experimentCanvas" class="w-full h-full bg-gray-50"></canvas>
                                            <div id="instructionOverlay" class="absolute top-4 left-4 bg-white/80 backdrop-blur-sm p-3 rounded-lg shadow-md max-w-xs">
                                                <h3 class="font-semibold text-primary mb-1">操作指南</h3>
                                                <p class="text-sm text-gray-700">拖动磁铁靠近或远离线圈，观察感应电流的变化</p>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- 右侧：数据显示与控制面板 -->
                                    <div class="lg:col-span-1 space-y-6 h-full overflow-y-auto">
                                        <!-- 数据显示面板 -->
                                        <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                                            <div class="p-4 bg-primary text-white">
                                                <h2 class="text-xl font-semibold">数据测量</h2>
                                            </div>
                                            <div class="p-4 grid grid-cols-2 gap-4">
                                                <div class="sensor-display p-3 bg-gray-50">
                                                    <h3 class="text-sm text-gray-500 mb-1">感应电动势</h3>
                                                    <div class="flex items-end">
                                                        <span id="emfValue" class="text-2xl font-bold text-primary">0.00</span>
                                                        <span class="ml-1 text-sm text-gray-600">V</span>
                                                    </div>
                                                </div>
                                                <div class="sensor-display p-3 bg-gray-50">
                                                    <h3 class="text-sm text-gray-500 mb-1">感应电流</h3>
                                                    <div class="flex items-end">
                                                        <span id="currentValue" class="text-2xl font-bold text-primary">0.00</span>
                                                        <span class="ml-1 text-sm text-gray-600">A</span>
                                                    </div>
                                                </div>
                                                <div class="sensor-display p-3 bg-gray-50">
                                                    <h3 class="text-sm text-gray-500 mb-1">磁通量</h3>
                                                    <div class="flex items-end">
                                                        <span id="fluxValue" class="text-2xl font-bold text-primary">0.00</span>
                                                        <span class="ml-1 text-sm text-gray-600">Wb</span>
                                                    </div>
                                                </div>
                                                <div class="sensor-display p-3 bg-gray-50">
                                                    <h3 class="text-sm text-gray-500 mb-1">磁通量变化率</h3>
                                                    <div class="flex items-end">
                                                        <span id="fluxRateValue" class="text-2xl font-bold text-primary">0.00</span>
                                                        <span class="ml-1 text-sm text-gray-600">Wb/s</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- 电流图表 -->
                                        <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                                            <div class="p-4 bg-primary text-white">
                                                <h2 class="text-xl font-semibold">电流-时间曲线</h2>
                                            </div>
                                            <div class="p-4">
                                                <canvas id="currentChart" height="200"></canvas>
                                            </div>
                                        </div>

                                        <!-- 控制面板 -->
                                        <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                                            <div class="p-4 bg-primary text-white">
                                                <h2 class="text-xl font-semibold">参数控制</h2>
                                            </div>
                                            <div class="p-4 space-y-4">
                                                <div>
                                                    <label for="coilTurns" class="block text-sm font-medium text-gray-700 mb-1">线圈匝数</label>
                                                    <input type="range" id="coilTurns" min="10" max="100" value="50" class="w-full">
                                                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                                                        <span>10匝</span>
                                                        <span id="coilTurnsValue">50匝</span>
                                                        <span>100匝</span>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label for="magnetStrength" class="block text-sm font-medium text-gray-700 mb-1">磁铁强度</label>
                                                    <input type="range" id="magnetStrength" min="0.1" max="2" step="0.1" value="1" class="w-full">
                                                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                                                        <span>弱</span>
                                                        <span id="magnetStrengthValue">中等</span>
                                                        <span>强</span>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label for="coilResistance" class="block text-sm font-medium text-gray-700 mb-1">线圈电阻 (Ω)</label>
                                                    <input type="range" id="coilResistance" min="1" max="20" value="10" class="w-full">
                                                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                                                        <span>1Ω</span>
                                                        <span id="coilResistanceValue">10Ω</span>
                                                        <span>20Ω</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="concept-explain">
                    <h3>概念解析</h3>
                    <p id="model-desc">点电荷产生的电场是电磁学中的基础概念。电场线从正电荷出发，终止于负电荷，其密度表示电场强度。电场强度E=kQ/r²，方向沿电场线切线方向，电势随距离增加而降低。通过调整电荷的位置、电荷量和类型，可以观察不同情况下的电场分布。</p>
                </div>
            </div>
        </div>
    </div>
    <!-- AI助教页面 -->
    <div id="assistant" class="page">
        <div class="container">
            <h2 class="page-title">电磁学AI助教</h2>
            <div class="assistant-container">
                <div class="chat-box">
                    <div class="chat-messages" id="chat-msgs">
                        <div class="message ai-message">
                            <div class="message-content">你好！我是你的电磁学助教，有问题可以问我~ 比如"什么是高斯定理？"、"如何计算电场强度？"、"带电粒子在磁场中如何运动？"</div>
                        </div>
                    </div>
                    <div class="chat-input">
                        <input type="text" id="user-input" placeholder="输入问题...">
                        <button onclick="sendMessage()">发送</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- 虚拟实验页面 -->
    <div id="experiment" class="page">
        <div class="container">
            <h2 class="page-title">电磁学虚拟实验</h2>
            <div class="experiment-container">
                <div class="exp-controls">
                    <div class="exp-list">
                        <h3>选择实验项目</h3>
                        <div class="exp-item active" onclick="selectExperiment('charge-motion')">
                            带电粒子在匀强电场中的运动
                        </div>
                        <div class="exp-item" onclick="selectExperiment('capacitor')">
                            平行板电容器电容影响因素
                        </div>
                    </div>
                    <div class="param-controls" id="param-controls">
                        <h3>实验参数调整</h3>
                        <div class="param-item">
                            <label for="electric-field">电场强度 (×10³ N/C)</label>
                            <input type="number" id="electric-field" value="5" min="1" max="20">
                        </div>
                        <div class="param-item">
                            <label for="particle-charge">粒子电荷量 (×10⁻¹⁹ C)</label>
                            <input type="number" id="particle-charge" value="1.6" step="0.1">
                        </div>
                        <div class="param-item">
                            <label for="initial-speed">初速度 (×10⁵ m/s)</label>
                            <input type="number" id="initial-speed" value="3" min="1" max="10">
                        </div>
                        <button class="start-btn" onclick="runExperiment()">开始实验</button>
                    </div>
                </div>
                <div class="exp-visual">
                    <h3 id="exp-title">带电粒子在匀强电场中的运动</h3>
                    <div class="exp-model">
                        <!-- 初始时不显示图片，直接显示实验容器 -->
                        <div id="charge-motion-container" class="w-full h-full"></div>
                    </div>
                    <!-- 数据记录模块向下移动 -->
                    <div class="mt-8">
                        <div class="exp-result" id="exp-result">
                            <p>实验说明：本实验模拟带电粒子在匀强电场中的偏转运动，可通过调整电场强度、粒子电荷量和初速度，观察粒子运动轨迹的变化。</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- 智能题库页面 -->
    <div id="question" class="page">
        <div class="container">
            <h2 class="page-title">电磁学智能题库</h2>
            <div class="question-filter">
                <div class="filter-row">
                    <div class="filter-item">
                        <label>知识点：</label>
                        <select id="knowledge-filter">
                            <option value="all">全部知识点</option>
                            <option value="electric-field">电场强度</option>
                            <option value="potential">电势与电势能</option>
                            <option value="gauss">高斯定理</option>
                            <option value="capacitor">电容器</option>
                            <option value="current">恒定电流</option>
                            <option value="magnetic-field">磁场</option>
                            <option value="induction">电磁感应</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>难度：</label>
                        <select id="difficulty-filter">
                            <option value="all">全部难度</option>
                            <option value="easy">基础</option>
                            <option value="medium">进阶</option>
                            <option value="hard">挑战</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <button class="filter-btn" onclick="filterQuestions()">筛选习题</button>
                    </div>
                </div>
            </div>
            <div class="question-list">
                <!-- 题目1：电场强度（基础） -->
                <div class="question-item" data-knowledge="electric-field" data-difficulty="easy">
                    <h4>1. 点电荷电场强度计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">电场强度</span>
                        <span class="question-tag">点电荷</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        真空中有一个电荷量为Q=5×10⁻⁶C的点电荷，求距离该电荷r=0.2m处的电场强度大小和方向。（静电力常量k=9×10⁹ N·m²/C²）
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(1, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目2：电势叠加（进阶） -->
                <div class="question-item" data-knowledge="potential" data-difficulty="medium">
                    <h4>2. 等量异种电荷的电势计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">电势</span>
                        <span class="question-tag">叠加原理</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        两个等量异种点电荷相距d=0.4m，电荷量分别为+Q和-Q（Q=2×10⁻⁶C）。求：（1）两电荷连线中点处的电势；（2）距离两电荷均为0.3m的点的电势。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(2, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目3：高斯定理（进阶） -->
                <div class="question-item" data-knowledge="gauss" data-difficulty="medium">
                    <h4>3. 均匀带电球体的电场分布</h4>
                    <div class="question-tags">
                        <span class="question-tag">高斯定理</span>
                        <span class="question-tag">电场分布</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一个半径为R=0.1m的均匀带电球体，总电荷量Q=3×10⁻⁵C。试推导球体球体内部（r < R）和外部（r > R）的电场强度分布公式，并计算r=0.05m和r=0.2m处的电场强度大小。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(3, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目4：电容器（基础） -->
                <div class="question-item" data-knowledge="capacitor" data-difficulty="easy">
                    <h4>4. 平行板电容器的电容计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">电容器</span>
                        <span class="question-tag">电容公式</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        一平行板电容器，极板面积S=0.02m²，极板间距d=0.5mm，中间充满相对介电常数εᵣ=5的电介质。求该电容器的电容大小。（真空介电常数ε₀=8.85×10⁻¹² F/m）
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(4, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目5：电磁感应感应（挑战） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="hard">
                    <h4>5. 动生电动势的计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">动生电动势</span>
                        <span class="question-tag">挑战</span>
                    </div>
                    <div class="question-content">
                        一根长度L=0.5m的导体棒，在磁感应强度B=0.2T的匀强磁场中以v=2m/s的速度垂直于磁场方向运动（导体棒与运动方向垂直）。求导体棒两端的动生电动势大小，若导体棒的电阻r=0.1Ω，外接电阻R=0.4Ω，求回路中的电流大小。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(5, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目6：电场强度叠加（基础） -->
                <div class="question-item" data-knowledge="electric-field" data-difficulty="easy">
                    <h4>6. 两个点电荷的电场叠加</h4>
                    <div class="question-tags">
                        <span class="question-tag">电场强度</span>
                        <span class="question-tag">叠加原理</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        真空中有两个点电荷，Q₁=4×10⁻⁶C位于(0,0)，Q₂=-2×10⁻⁶C位于(0.3m,0)。求点P(0.15m,0)处的电场强度大小和方向。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(6, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目7：电势计算（基础） -->
                <div class="question-item" data-knowledge="potential" data-difficulty="easy">
                    <h4>7. 点电荷电势计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">电势</span>
                        <span class="question-tag">点电荷</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        真空中有一个点电荷Q=3×10⁻⁶C，求距离该电荷0.1m处的电势。如果将另一个点电荷q=2×10⁻⁹C放在该点，求它的电势能。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(7, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目8：电容器连接（基础） -->
                <div class="question-item" data-knowledge="capacitor" data-difficulty="easy">
                    <h4>8. 电容器的串联与并联</h4>
                    <div class="question-tags">
                        <span class="question-tag">电容器</span>
                        <span class="question-tag">串并联</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        两个电容器C₁=4μF，C₂=6μF，求：(1)它们串联后的等效电容；(2)它们并联后的等效电容；(3)如果串联后接在12V电源上，求每个电容器的电压。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(8, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目9：欧姆定律应用（基础） -->
                <div class="question-item" data-knowledge="current" data-difficulty="easy">
                    <h4>9. 简单电路中的电流计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">恒定电流</span>
                        <span class="question-tag">欧姆定律</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        一个电阻R=10Ω接在U=5V的电源两端，求：(1)通过电阻的电流；(2)电阻消耗的功率；(3)1分钟内电阻产生的热量。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(9, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目10：电阻串并联（基础） -->
                <div class="question-item" data-knowledge="current" data-difficulty="easy">
                    <h4>10. 混联电路计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">恒定电流</span>
                        <span class="question-tag">串并联</span>
                        <span class="question-tag">基础</span>
                    </div>
                    <div class="question-content">
                        三个电阻R₁=2Ω，R₂=3Ω，R₃=6Ω，连接方式为R₂与R₃并联后再与R₁串联。如果电路总电压U=12V，求：(1)总电阻；(2)总电流；(3)通过每个电阻的电流。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(10, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目11：电场中的能量（进阶） -->
                <div class="question-item" data-knowledge="potential" data-difficulty="medium">
                    <h4>11. 电场中的功能关系</h4>
                    <div class="question-tags">
                        <span class="question-tag">电势能</span>
                        <span class="question-tag">电场力做功</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        匀强电场E=100V/m中，有A、B两点，AB=0.1m且与电场方向成60°角。将q=2×10⁻⁶C的电荷从A移到B，求：(1)电场力做的功；(2)A、B两点间的电势差；(3)电荷电势能的变化。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(11, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目12：带电粒子在电场中运动（进阶） -->
                <div class="question-item" data-knowledge="electric-field" data-difficulty="medium">
                    <h4>12. 带电粒子在匀强电场中的偏转</h4>
                    <div class="question-tags">
                        <span class="question-tag">电场</span>
                        <span class="question-tag">带电粒子</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一电子以v₀=2×10⁷m/s的初速度沿水平方向射入匀强电场，电场强度E=2×10⁴V/m，方向竖直向上，极板长度L=0.1m。求：(1)电子在电场中的加速度；(2)电子飞出电场时的偏转距离；(3)飞出电场时的速度大小和方向。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(12, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目13：高斯定理应用（进阶） -->
                <div class="question-item" data-knowledge="gauss" data-difficulty="medium">
                    <h4>13. 无限长带电直线的电场</h4>
                    <div class="question-tags">
                        <span class="question-tag">高斯定理</span>
                        <span class="question-tag">对称电场</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        利用高斯定理求无限长均匀带电直线的电场分布。已知线电荷密度λ=2×10⁻⁶C/m，求距离直线0.1m处的电场强度大小。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(13, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目14：闭合电路计算（进阶） -->
                <div class="question-item" data-knowledge="current" data-difficulty="medium">
                    <h4>14. 闭合电路欧姆定律应用</h4>
                    <div class="question-tags">
                        <span class="question-tag">恒定电流</span>
                        <span class="question-tag">闭合电路</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        电源电动势E=12V，内阻r=1Ω，外电路电阻R=5Ω。求：(1)电路中的电流；(2)路端电压；(3)电源的输出功率；(4)电源的效率。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(14, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目15：安培力计算（进阶） -->
                <div class="question-item" data-knowledge="magnetic-field" data-difficulty="medium">
                    <h4>15. 通电直导线在磁场中的受力</h4>
                    <div class="question-tags">
                        <span class="question-tag">磁场</span>
                        <span class="question-tag">安培力</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一段直导线长L=0.5m，通以I=2A的电流，放置在B=0.1T的匀强磁场中，导线与磁场方向成30°角。求导线所受安培力的大小和方向。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(15, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目16：洛伦兹力应用（进阶） -->
                <div class="question-item" data-knowledge="magnetic-field" data-difficulty="medium">
                    <h4>16. 带电粒子在磁场中的圆周运动</h4>
                    <div class="question-tags">
                        <span class="question-tag">磁场</span>
                        <span class="question-tag">洛伦兹力</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一质子以v=3×10⁶m/s的速度垂直进入B=0.1T的匀强磁场。已知质子质量m=1.67×10⁻²⁷kg，电荷量q=1.6×10⁻¹⁹C。求：(1)质子在磁场中做圆周运动的半径；(2)运动周期；(3)动能。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(16, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目17：电磁感应定律（进阶） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="medium">
                    <h4>17. 法拉第电磁感应定律应用</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">法拉第定律</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一个100匝的线圈，在0.2s内磁通量从0.01Wb均匀增加到0.05Wb。求：(1)线圈中的感应电动势；(2)如果线圈电阻为2Ω，感应电流的大小。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(17, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目18：动生电动势（进阶） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="medium">
                    <h4>18. 导体切割磁感线的电动势</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">动生电动势</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一根长度L=0.4m的导体棒，在B=0.5T的匀强磁场中以v=3m/s的速度垂直于磁场方向运动。求：(1)导体棒中的动生电动势；(2)如果导体棒电阻为0.2Ω，外接电阻为0.8Ω，求回路中的电流。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(18, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目19：自感现象（进阶） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="medium">
                    <h4>19. 自感电动势的计算</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">自感</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一个自感系数L=0.2H的线圈，当通过它的电流在0.01s内从0.5A均匀增加到2A时，求：(1)线圈中的自感电动势；(2)线圈储存的磁场能。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(19, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目20：交流电计算（进阶） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="medium">
                    <h4>20. 交流电路中的有效值</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">交流电</span>
                        <span class="question-tag">进阶</span>
                    </div>
                    <div class="question-content">
                        一交流电的表达式为i=5sin(100πt+π/3)A，求：(1)电流的峰值、有效值；(2)频率、周期；(3)初相位；(4)t=0.01s时的瞬时值。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(20, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目21：复合场问题（挑战） -->
                <div class="question-item" data-knowledge="electric-field" data-difficulty="hard">
                    <h4>21. 带电粒子在复合场中的运动</h4>
                    <div class="question-tags">
                        <span class="question-tag">电场</span>
                        <span class="question-tag">磁场</span>
                        <span class="question-tag">复合场</span>
                        <span class="question-tag">挑战</span>
                    </div>
                    <div class="question-content">
                        一带电粒子质量m=2×10⁻¹⁶kg，电荷量q=4×10⁻¹⁹C，以速度v=10⁴m/s垂直进入互相垂直的匀强电场和匀强磁场区域，E=10⁴V/m，B=0.02T。若粒子能直线通过该区域，求：(1)电场和磁场的方向关系；(2)粒子速度方向；(3)若撤去电场，粒子在磁场中运动的轨道半径。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(21, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目22：电磁感应综合（挑战） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="hard">
                    <h4>22. 电磁感应中的能量转化</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">能量守恒</span>
                        <span class="question-tag">挑战</span>
                    </div>
                    <div class="question-content">
                        两根足够长的平行金属导轨固定在水平面上，间距L=0.5m，右端接R=2Ω的电阻，整个装置处于B=0.8T的匀强磁场中。质量m=0.1kg、电阻r=0.5Ω的导体棒以初速度v₀=4m/s向右滑动，导轨电阻不计且足够长。求：(1)初始时刻回路中的电流；(2)导体棒最终的速度；(3)全过程中电阻R上产生的热量。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(22, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目23：变压器应用（挑战） -->
                <div class="question-item" data-knowledge="induction" data-difficulty="hard">
                    <h4>23. 理想变压器与远距离输电</h4>
                    <div class="question-tags">
                        <span class="question-tag">电磁感应</span>
                        <span class="question-tag">变压器</span>
                        <span class="question-tag">挑战</span>
                    </div>
                    <div class="question-content">
                        发电站输出功率P=100kW，输出电压U₁=250V，升压变压器原副线圈匝数比1:20，输电线总电阻R=10Ω，用户端降压变压器原副线圈匝数比10:1。求：(1)输电线上的电流；(2)用户得到的电压；(3)用户得到的功率；(4)输电效率。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(23, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目24：电磁场综合（挑战） -->
                <div class="question-item" data-knowledge="magnetic-field" data-difficulty="hard">
                    <h4>24. 回旋加速器原理</h4>
                    <div class="question-tags">
                        <span class="question-tag">磁场</span>
                        <span class="question-tag">加速器</span>
                        <span class="question-tag">挑战</span>
                    </div>
                    <div class="question-content">
                        一回旋加速器D形盒半径R=0.5m，磁感应强度B=1T，加速电压U=2×10⁴V。现加速质子，已知质子质量m=1.67×10⁻²⁷kg，电荷量q=1.6×10⁻¹⁹C。求：(1)质子获得的最大动能；(2)质子运动的最大速率；(3)交变电场的频率。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(24, event)">查看答案</button>
                    </div>
                </div>
                <!-- 题目25：综合应用题（挑战） -->
                <div class="question-item" data-knowledge="electric-field" data-difficulty="hard">
                    <h4>25. 质谱仪原理分析</h4>
                    <div class="question-tags">
                        <span class="question-tag">电场</span>
                        <span class="question-tag">磁场</span>
                        <span class="question-tag">质谱仪</span>
                        <span class="question-tag">挑战</span>
                    </div>
                    <div class="question-content">
                        质谱仪原理如图所示，离子源产生初速度可忽略的正离子，经加速电压U加速后垂直进入磁感应强度为B的匀强磁场，做半径为R的圆周运动。证明：离子的比荷q/m=2U/(B²R²)，并说明如何利用质谱仪分离同位素。
                    </div>
                    <div class="question-action">
                        <button class="view-answer" onclick="showAnswer(25, event)">查看答案</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <div class="container">
            <p>电磁AI课堂 © 2024 物理系教学项目</p>
        </div>
    </footer>
    
    <!-- 电磁感应实验的JavaScript代码 -->
    <script>
        // 页面切换核心函数
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            window.scrollTo(0, 0);
            
            // 如果切换到概念可视化页面，且当前是点电荷模型，初始化3D场景
            if (pageId === 'concept' && document.querySelector('.model-type.active').getAttribute('onclick').includes('point')) {
                if (!window.pointChargeSceneInitialized) {
                    initPointChargeScene();
                    window.pointChargeSceneInitialized = true;
                }
            }
            
            // 如果切换到概念可视化页面，且当前是电磁感应模型，初始化电磁感应实验
            if (pageId === 'concept' && document.querySelector('.model-type.active').getAttribute('onclick').includes('induction')) {
                if (!window.inductionExperimentInitialized) {
                    initInductionExperiment();
                    window.inductionExperimentInitialized = true;
                }
            }
            
            // 如果切换到虚拟实验页面，初始化带电粒子实验
            if (pageId === 'experiment') {
                // 初始化带电粒子实验
                if (!window.chargeMotionInitialized) {
                    initChargeMotionExperiment();
                    window.chargeMotionInitialized = true;
                }
            }
        }
        
        // 概念馆模型模型切换
        function changeModel(modelType) {
            document.querySelectorAll('.model-type').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            
            // 隐藏所有可视化
            document.getElementById('point-charge-visual').classList.add('hidden');
            document.getElementById('induction-visual').classList.add('hidden');
            
            const desc = document.getElementById('model-desc');
            
            if (modelType === 'point') {
                document.getElementById('point-charge-visual').classList.remove('hidden');
                desc.textContent = '点电荷产生的电场是电磁学中的基础概念。电场线从正电荷出发，终止于负电荷，其密度表示电场强度。电场强度E=kQ/r²，方向沿电场线切线方向，电势随距离增加而降低。通过调整电荷的位置、电荷量和类型，可以观察不同情况下的电场分布。';
                
                // 初始化3D场景
                if (!window.pointChargeSceneInitialized) {
                    initPointChargeScene();
                    window.pointChargeSceneInitialized = true;
                }
            } else if (modelType === 'induction') {
                document.getElementById('induction-visual').classList.remove('hidden');
                desc.textContent = '电磁感应是指导体回路中的磁通量发生变化时，回路中会产生感应电动势的现象。法拉第电磁感应定律指出，感应电动势的大小与磁通量变化率成正比，方向由楞次定律决定。';
                
                // 初始化电磁感应实验
                if (!window.inductionExperimentInitialized) {
                    initInductionExperiment();
                    window.inductionExperimentInitialized = true;
                }
            }
        }
        
        // 扩展的AI助教知识库函数
        function getAIResponse(question) {
            // 转换为小写便于匹配
            const q = question.toLowerCase();
            
            // 静电场相关问题
            if (q.includes('电场强度') && q.includes('计算')) {
                return "电场强度计算：\n1. 点电荷电场：E = kQ/r²，方向沿径向\n2. 匀强电场：E = U/d，方向由正极指向负极\n3. 多个电荷叠加：使用矢量叠加原理\n4. 特殊对称性：可使用高斯定理简化计算";
            }
            
            if (q.includes('电势') && q.includes('电势能')) {
                return "电势与电势能：\n1. 电势(φ)：单位正电荷在某点的电势能，φ = Ep/q\n2. 电势能(Ep)：电荷在电场中具有的能量，Ep = qφ\n3. 电势差(U)：两点电势之差，U = φ₁ - φ₂\n4. 电场力做功：W = qU = -ΔEp，与路径无关";
            }
            
            if (q.includes('等势面') || q.includes('等势线')) {
                return "等势面：\n1. 电场中电势相等的点构成的面\n2. 等势面与电场线处处垂直\n3. 沿等势面移动电荷，电场力不做功\n4. 等势面密集处电场强度大，稀疏处电场强度小";
            }
            
            if (q.includes('静电平衡') || q.includes('导体')) {
                return "静电平衡：\n1. 导体内部场强处处为零\n2. 净电荷只分布在导体表面\n3. 导体表面是等势面，内部是等势体\n4. 导体表面附近场强垂直于表面，E = σ/ε₀";
            }
            
            if (q.includes('电容器') && q.includes('电容')) {
                return "电容器与电容：\n1. 电容定义：C = Q/U，单位法拉(F)\n2. 平行板电容：C = ε₀εᵣS/d\n3. 电容串联：1/C = 1/C₁ + 1/C₂ + ...\n4. 电容并联：C = C₁ + C₂ + ...\n5. 电容器储能：W = ½CU² = ½QU = Q²/(2C)";
            }
            
            // 恒定电流相关问题
            if (q.includes('欧姆定律') || q.includes('电流')) {
                return "电流与欧姆定律：\n1. 电流定义：I = Q/t，单位安培(A)\n2. 欧姆定律：I = U/R，适用于金属和电解液\n3. 电阻定律：R = ρL/S，ρ为电阻率\n4. 电功率：P = UI = I²R = U²/R";
            }
            
            if (q.includes('串并联') || q.includes('电阻')) {
                return "电阻串并联：\n1. 串联：R = R₁ + R₂ + ...，电流相等\n2. 并联：1/R = 1/R₁ + 1/R₂ + ...，电压相等\n3. 分压公式：U₁/U = R₁/R\n4. 分流公式：I₁/I = R/R₁";
            }
            
            if (q.includes('闭合电路') || q.includes('电动势')) {
                return "闭合电路欧姆定律：\n1. 电动势(E)：电源将其他形式能转化为电能的本领\n2. 闭合电路：I = E/(R + r)，r为内阻\n3. 路端电压：U = E - Ir\n4. 电源功率：P总 = EI，P输出 = UI，P内 = I²r";
            }
            
            if (q.includes('电功') || q.includes('电功率')) {
                return "电功与电功率：\n1. 电功：W = UIt = I²Rt = U²t/R\n2. 电功率：P = W/t = UI = I²R = U²/R\n3. 焦耳定律：Q = I²Rt（纯电阻电路）\n4. 额定功率：用电器正常工作时的功率";
            }
            
            // 磁场相关问题
            if (q.includes('磁感应强度') || q.includes('磁场')) {
                return "磁场与磁感应强度：\n1. 磁感应强度(B)：描述磁场强弱和方向的物理量\n2. 磁感线：闭合曲线，外部N→S，内部S→N\n3. 安培定则：判断电流磁场方向\n4. 地磁场：地球本身产生的磁场";
            }
            
            if (q.includes('安培力') || q.includes('磁场对电流')) {
                return "安培力：\n1. 大小：F = BILsinθ，θ为B与I夹角\n2. 方向：左手定则（磁场穿手心，四指电流，拇指受力）\n3. 应用：电动机、电流表等\n4. 平行导线相互作用：同向相吸，反向相斥";
            }
            
            if (q.includes('洛伦兹力') || q.includes('磁场对运动电荷')) {
                return "洛伦兹力：\n1. 大小：F = qvBsinθ，θ为v与B夹角\n2. 方向：左手定则（正电荷），负电荷相反\n3. 特点：永不做功，只改变速度方向\n4. 应用：质谱仪、回旋加速器、霍尔效应";
            }
            
            if (q.includes('带电粒子') && q.includes('磁场')) {
                return "带电粒子在磁场中运动：\n1. v∥B：匀速直线运动\n2. v⊥B：匀速圆周运动，半径 r = mv/(qB)，周期 T = 2πm/(qB)\n3. 一般情况：螺旋运动\n4. 速度选择器：qvB = qE ⇒ v = E/B";
            }
            
            // 电磁感应相关问题
            if (q.includes('法拉第') || q.includes('电磁感应')) {
                return "电磁感应定律：\n1. 法拉第定律：ε = -nΔΦ/Δt\n2. 楞次定律：感应电流的磁场总是阻碍引起感应电流的磁通量变化\n3. 感应电动势方向：右手定则或楞次定律判断";
            }
            
            if (q.includes('动生电动势') || q.includes('感生电动势')) {
                return "感应电动势分类：\n1. 动生电动势：导体切割磁感线产生，ε = BLvsinθ\n2. 感生电动势：磁场变化产生，ε = -nΔΦ/Δt\n3. 自感电动势：ε = -LΔI/Δt，L为自感系数\n4. 互感电动势：一个线圈电流变化在另一个线圈产生电动势";
            }
            
            if (q.includes('自感') || q.includes('互感')) {
                return "自感与互感：\n1. 自感：线圈自身电流变化产生感应电动势的现象\n2. 自感系数(L)：与线圈形状、大小、匝数及有无铁芯有关\n3. 互感：两个线圈间通过磁场相互影响的现象\n4. 应用：变压器、感应圈等";
            }
            
            if (q.includes('交流电') || q.includes('正弦')) {
                return "交流电：\n1. 表达式：e = Emsin(ωt+φ)，i = Imsin(ωt+φ)\n2. 峰值(Em,Im)、有效值(E = Em/√2, I = Im/√2)\n3. 周期(T)、频率(f)、角频率(ω)：ω = 2πf = 2π/T\n4. 相位：描述交流电变化步调的物理量";
            }
            
            if (q.includes('变压器') || q.includes('远距离输电')) {
                return "变压器与远距离输电：\n1. 理想变压器：U₁/U₂ = n₁/n₂，I₁/I₂ = n₂/n₁，P₁ = P₂\n2. 实际变压器：有能量损失（铜损、铁损）\n3. 远距离输电：提高电压减小电流，降低线路损耗\n4. 输电效率：η = P输出/P输入 × 100%";
            }
            
            // 综合应用问题
            if (q.includes('质谱仪') || q.includes('回旋加速器')) {
                return "电磁学应用仪器：\n1. 质谱仪：分离同位素，q/m = 2U/(B²r²)\n2. 回旋加速器：加速带电粒子，最大动能 Ekmax = (q²B²R²)/(2m)\n3. 速度选择器：v = E/B\n4. 霍尔效应：UH = kIB/d，判断载流子类型";
            }
            
            if (q.includes('麦克斯韦') || q.includes('电磁波')) {
                return "电磁场理论与电磁波：\n1. 麦克斯韦方程组：描述电磁场的基本规律\n2. 电磁波：变化的电场和磁场相互激发，在空间传播\n3. 电磁波谱：无线电波→红外线→可见光→紫外线→X射线→γ射线\n4. 电磁波特点：横波、传播不需介质、真空中速度c=3×10⁸m/s";
            }
            
            // 如果问题不匹配任何已知模式
            return "这个问题涉及电磁学的核心概念。建议您：\n1. 明确具体知识点（如电场、磁场、电磁感应等）\n2. 提供更具体的问题描述\n3. 尝试使用概念可视化功能观察物理现象\n4. 通过虚拟实验验证理论结果\n\n我可以帮助您解答关于电场强度、电势、电流、磁场、电磁感应等方面的问题。";
        }
        
        // AI助教消息发送
        function sendMessage() {
            const input = document.getElementById('user-input');
            const question = input.value.trim();
            if (!question) return;
            
            const chatBox = document.getElementById('chat-msgs');
            
            // 添加用户消息
            const userMsg = document.createElement('div');
            userMsg.className = 'message user-message';
            userMsg.innerHTML = `<div class="message-content">${question}</div>`;
            chatBox.appendChild(userMsg);
            
            // AI回复（扩展知识库）
            let reply = getAIResponse(question);
            
            // 添加AI回复
            const aiMsg = document.createElement('div');
            aiMsg.className = 'message ai-message';
            aiMsg.innerHTML = `<div class="message-content">${reply}</div>`;
            chatBox.appendChild(aiMsg);
            
            // 清空输入并滚动到底部
            input.value = '';
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        // 虚拟实验：选择实验项目
        function selectExperiment(expType) {
            document.querySelectorAll('.exp-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            const expTitle = document.getElementById('exp-title');
            const expModel = document.querySelector('.exp-model');
            
            // 清空实验区域
            expModel.innerHTML = '';
            
            if (expType === 'charge-motion') {
                expTitle.textContent = '带电粒子在匀强电场中的运动';
                
                // 创建粒子运动实验的容器
                const chargeMotionContainer = document.createElement('div');
                chargeMotionContainer.id = 'charge-motion-container';
                chargeMotionContainer.style.width = '100%';
                chargeMotionContainer.style.height = '100%';
                expModel.appendChild(chargeMotionContainer);
                
                // 加载粒子运动实验
                initChargeMotionExperiment();
                
            } else if (expType === 'capacitor') {
                expTitle.textContent = '平行行板电容器电容影响因素';
                
                // 创建电容器实验的容器
                const capacitorContainer = document.createElement('div');
                capacitorContainer.id = 'capacitor-container';
                capacitorContainer.style.width = '100%';
                capacitorContainer.style.height = '100%';
                expModel.appendChild(capacitorContainer);
                
                // 加载电容器实验
                initCapacitorExperiment();
            }
            
            // 重置实验结果
            document.getElementById('exp-result').innerHTML = `<p>实验说明：请调整参数数并点击"开始实验"查看结果。</p>`;
        }
        
        // 虚拟实验：运行实验
        function runExperiment() {
            const activeExp = document.querySelector('.exp-item.active').textContent;
            const resultDiv = document.getElementById('exp-result');
            
            if (activeExp.includes('带电粒子')) {
                // 触发粒子运动实验的开始按钮
                const startBtn = document.getElementById('startBtn');
                if (startBtn && !startBtn.disabled) {
                    startBtn.click();
                }
                
                resultDiv.innerHTML = `
                    <p><strong>实验结果：</strong></p>
                    <p>1. 带电粒子在匀强电场中做类平抛运动</p>
                    <p>2. 粒子加速度：a = qE/m，与电荷量成正比，与质量成反比</p>
                    <p>3. 偏转距离与电场强度、电荷量成正比，与初速度平方成反比</p>
                    <p>4. 可以通过调节左侧参数观察粒子运动轨迹的变化</p>
                `;
                
            } else if (activeExp.includes('电容器')) {
                // 触发电容器实验的开始按钮
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.click();
                }
                
                resultDiv.innerHTML = `
                    <p><strong>实验结果：</strong></p>
                    <p>1. 平行板电容器电容C = ε₀εᵣS/d</p>
                    <p>2. 电容与极板面积S成正比，与极板间距d成反比</p>
                    <p>3. 电容与介电常数εᵣ成正比</p>
                    <p>4. 可以通过调节左侧参数观察电容值的变化</p>
                `;
            }
        }
        
        // 智能题库：筛选习题
        function filterQuestions() {
            const knowledge = document.getElementById('knowledge-filter').value;
            const difficulty = document.getElementById('difficulty-filter').value;
            const questions = document.querySelectorAll('.question-item');
            
            questions.forEach(question => {
                const qKnowledge = question.getAttribute('data-knowledge');
                const qDifficulty = question.getAttribute('data-difficulty');
                const knowledgeMatch = knowledge === 'all' || qKnowledge === knowledge;
                const difficultyMatch = difficulty === 'all' || qDifficulty === difficulty;
                
                if (knowledgeMatch && difficultyMatch) {
                    question.classList.remove('hidden');
                } else {
                    question.classList.add('hidden');
                }
            });
        }
        
        // 智能题库：显示答案
        function showAnswer(id, event) {
            event.stopPropagation();
            const answers = {
                1: `答案：\n1. 电场强度大小：E = kQ/r² = 9×10⁹ × 5×10⁻⁶ / (0.2)² = 1.125×10⁶ N/C\n2. 方向：若Q为正电荷，方向背离点电荷；若Q为负电荷，方向指向点电荷。`,
                2: `答案：\n1. 中点电势：φ = φ₊ + φ₋ = kQ/(d/2) + k(-Q)/(d/2) = 0\n2. 等距点电势：两点电荷到该点的距离相等（均为0.3m），故φ = kQ/0.3 + k(-Q)/0.3 = 0`,
                3: `答案：\n1. 内部（r < R）：E = (kQ/R³)r（推导用高斯定理，内部电荷与r³成正比）\n r=0.05m处：E = (9×10⁹×3×10⁻⁵)/(0.1³) × 0.05 = 1.35×10⁷ N/C\n2. 外部（r > R）：E = kQ/r²（与点电荷电场一致）\n r=0.2m处：E = 9×10⁹×3×10⁻⁵ / (0.2)² = 6.75×10⁶ N/C`,
                4: `答案：\n电容公式 C = (ε₀εᵣS)/d\n代入数据：C = (8.85×10⁻¹² × 5 × 0.02) / (0.5×10⁻³) ≈ 1.77×10⁻⁹ F = 1.77 nF`,
                5: `答案：\n1. 动生电动势：ε = BLv = 0.2×0.5×2 = 0.2 V\n2. 回路电流：I = ε/(R+r) = 0.2/(0.4+0.1) = 0.4 A`,
                6: `答案：\n1. E₁ = kQ₁/r₁² = 9×10⁹×4×10⁻⁶/(0.15)² = 1.6×10⁶ N/C (方向向右)\n2. E₂ = k|Q₂|/r₂² = 9×10⁹×2×10⁻⁶/(0.15)² = 0.8×10⁶ N/C (方向向左)\n3. E = E₁ - E₂ = 0.8×10⁶ N/C (方向向右)`,
                7: `答案：\n1. 电势 φ = kQ/r = 9×10⁹×3×10⁻⁶/0.1 = 2.7×10⁵ V\n2. 电势能 Ep = qφ = 2×10⁻⁹×2.7×10⁵ = 5.4×10⁻⁴ J`,
                8: `答案：\n1. 串联：C = C₁C₂/(C₁+C₂) = 4×6/(4+6) = 2.4μF\n2. 并联：C = C₁+C₂ = 4+6 = 10μF\n3. 串联时：U₁ = C₂U/(C₁+C₂) = 6×12/(4+6) = 7.2V, U₂ = 12-7.2 = 4.8V`,
                9: `答案：\n1. 电流 I = U/R = 5/10 = 0.5A\n2. 功率 P = UI = 5×0.5 = 2.5W\n3. 热量 Q = I²Rt = 0.5²×10×60 = 150J`,
                10: `答案：\n1. 总电阻 R = R₁ + R₂R₃/(R₂+R₃) = 2 + 3×6/(3+6) = 2+2 = 4Ω\n2. 总电流 I = U/R = 12/4 = 3A\n3. I₁ = 3A, I₂ = I×R₃/(R₂+R₃) = 3×6/9 = 2A, I₃ = 3-2 = 1A`,
                11: `答案：\n1. 功 W = qEdcosθ = 2×10⁻⁶×100×0.1×cos60° = 1×10⁻⁶ J\n2. 电势差 U = W/q = 1×10⁻⁶/2×10⁻⁶ = 0.5V\n3. ΔEp = -W = -1×10⁻⁶ J (电势能减少)`,
                12: `答案：\n1. 加速度 a = eE/m = 1.6×10⁻¹⁹×2×10⁴/9.1×10⁻³¹ ≈ 3.52×10¹⁵ m/s²\n2. 偏转距离 y = ½at² = ½×3.52×10¹⁵×(0.1/2×10⁷)² ≈ 0.044m\n3. v_x = 2×10⁷ m/s, v_y = at = 3.52×10¹⁵×5×10⁻⁹ = 1.76×10⁷ m/s\n   v = √(v_x²+v_y²) ≈ 2.66×10⁷ m/s, tanθ = v_y/v_x = 0.88`,
                13: `答案：\n1. 高斯面选为以导线为轴的圆柱面，高h，半径r\n2. Φ = E×2πrh = λh/ε₀ ⇒ E = λ/(2πε₀r)\n3. E = 2×10⁻⁶/(2π×8.85×10⁻¹²×0.1) ≈ 3.6×10⁵ N/C`,
                14: `答案：\n1. 电流 I = E/(R+r) = 12/(5+1) = 2A\n2. 路端电压 U = IR = 2×5 = 10V\n3. 输出功率 P = UI = 10×2 = 20W\n4. 效率 η = U/E = 10/12 ≈ 83.3%`,
                15: `答案：\n1. 安培力大小 F = BILsinθ = 0.1×2×0.5×sin30° = 0.05N\n2. 方向：由左手定则确定，垂直于B和I所在平面`,
                16: `答案：\n1. 半径 r = mv/(qB) = 1.67×10⁻²⁷×3×10⁶/(1.6×10⁻¹⁹×0.1) ≈ 0.313m\n2. 周期 T = 2πm/(qB) = 2π×1.67×10⁻²⁷/(1.6×10⁻¹⁹×0.1) ≈ 6.56×10⁻⁷s\n3. 动能 Ek = ½mv² = ½×1.67×10⁻²⁷×(3×10⁶)² ≈ 7.52×10⁻¹⁵J`,
                17: `答案：\n1. 感应电动势 ε = -nΔΦ/Δt = -100×(0.05-0.01)/0.2 = -20V (大小为20V)\n2. 感应电流 I = ε/R = 20/2 = 10A`,
                18: `答案：\n1. 动生电动势 ε = BLv = 0.5×0.4×3 = 0.6V\n2. 回路电流 I = ε/(R+r) = 0.6/(0.8+0.2) = 0.6A`,
                19: `答案：\n1. 自感电动势 ε = -LΔI/Δt = -0.2×(2-0.5)/0.01 = -30V (大小为30V)\n2. 磁场能 W = ½LI² = ½×0.2×2² = 0.4J`,
                20: `答案：\n1. 峰值 Im=5A，有效值 I=Im/√2=5/1.414≈3.54A\n2. 频率 f=ω/2π=100π/2π=50Hz，周期 T=1/f=0.02s\n3. 初相位 φ=π/3=60°\n4. i=5sin(100π×0.01+π/3)=5sin(π+π/3)=5sin(4π/3)≈-4.33A`,
                21: `答案：\n1. 电场力与洛伦兹力平衡：qE=qvB ⇒ E=vB，电场与磁场方向垂直\n2. 速度方向垂直于E和B，且满足E=vB\n3. 半径 r=mv/(qB)=2×10⁻¹⁶×10⁴/(4×10⁻¹⁹×0.02)=0.25m`,
                22: `答案：\n1. 初始电流 I=BLv₀/(R+r)=0.8×0.5×4/(2+0.5)=0.64A\n2. 最终速度 v=0 (因无外力，安培力使其减速至停止)\n3. 热量 Q=½mv₀²=½×0.1×4²=0.8J，R上热量 Q_R=Q×R/(R+r)=0.8×2/2.5=0.64J`,
                23: `答案：\n1. 升压后电压 U₂=20×250=5000V，输电线电流 I=P/U₂=100000/5000=20A\n2. 降压前电压 U₃=U₂-IR=5000-20×10=4800V，用户电压 U₄=U₃/10=480V\n3. 用户功率 P₄=U₄I=480×20=96000W=96kW\n4. 效率 η=P₄/P=96/100=96%`,
                24: `答案：\n1. 最大动能 Ek_max=(q²B²R²)/(2m)=(1.6×10⁻¹⁹)²×1²×0.5²/(2×1.67×10⁻²⁷)≈1.92×10⁻¹²J=12MeV\n2. 最大速率 v_max=qBR/m=1.6×10⁻¹⁹×1×0.5/1.67×10⁻²⁷≈4.79×10⁷m/s\n3. 频率 f=qB/(2πm)=1.6×10⁻¹⁹×1/(2π×1.67×10⁻²⁷)≈1.52×10⁷Hz=15.2MHz`,
                25: `答案：\n证明：\n1. 加速过程：½mv²=qU ⇒ v²=2qU/m\n2. 磁场中圆周运动：qvB=mv²/R ⇒ q/m=v/(BR)\n3. 联立得：q/m=2U/(B²R²)\n\n应用：\n不同同位素质量不同，在相同条件下做圆周运动的半径不同，从而在照相底片上形成不同的谱线，实现分离。`
            };
            
            alert(`题目${id}答案：\n\n${answers[id]}`);
        }
        
        // ===== 带电粒子在匀强电场中的运动实验 =====
        function initChargeMotionExperiment() {
            // 创建实验所需的HTML结构
            const container = document.getElementById('charge-motion-container');
            container.innerHTML = `
                <div class="flex flex-col h-full">
                    <div class="flex-1 relative">
                        <canvas id="simulationCanvas" class="w-full h-full"></canvas>
                        <div id="canvasOverlay" class="absolute top-0 left-0 w-full h-full flex items-center justify-center pointer-events-none">
                            <div id="startMessage" class="bg-primary bg-opacity-80 text-white text-xl font-bold px-6 py-3 rounded-lg">
                                点击"开始"按钮启动模拟
                            </div>
                        </div>
                        <!-- 实时数据显示面板 -->
                        <div id="dataPanel" class="absolute bottom-0 left-0 w-full bg-white bg-opacity-90 p-3 shadow-lg rounded-t-lg">
                            <div class="grid grid-cols-3 gap-2 text-sm">
                                <div>
                                    <span class="font-bold">位置:</span>
                                    <span id="position">x: 0.00 m, y: 0.00 m</span>
                                </div>
                                <div>
                                    <span class="font-bold">速度:</span>
                                    <span id="velocity">5.00 m/s, 0°</span>
                                </div>
                                <div>
                                    <span class="font-bold">加速度:</span>
                                    <span id="acceleration">0.00 m/s², 90°</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- 公式显示区域 -->
                    <div class="bg-white p-3 mt-2 rounded-lg shadow">
                        <h4 class="font-bold mb-2">相关公式:</h4>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>E = F/q</div>
                            <div>F = qE</div>
                            <div>a = F/m = qE/m</div>
                            <div>v = v₀ + at</div>
                            <div>s = s₀ + v₀t + ½at²</div>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加Tailwind CSS和Font Awesome
            if (!document.getElementById('tailwind-css')) {
                const tailwindScript = document.createElement('script');
                tailwindScript.id = 'tailwind-css';
                tailwindScript.src = 'https://cdn.tailwindcss.com';
                document.head.appendChild(tailwindScript);
            }
            
            if (!document.getElementById('font-awesome')) {
                const fontAwesomeLink = document.createElement('link');
                fontAwesomeLink.id = 'font-awesome';
                fontAwesomeLink.href = 'https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css';
                fontAwesomeLink.rel = 'stylesheet';
                document.head.appendChild(fontAwesomeLink);
            }
            
            // 添加自定义样式
            const style = document.createElement('style');
            style.textContent = `
                .glass {
                    background: rgba(255, 255, 255, 0.25);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.18);
                }
                .shadow-soft {
                    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
                }
                .slider-thumb::-webkit-slider-thumb {
                    appearance: none;
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    background: #1E40AF;
                    border: 2px solid white;
                    cursor: pointer;
                }
                .slider-track {
                    appearance: none;
                    height: 8px;
                    border-radius: 4px;
                    background: #dbeafe;
                }
            `;
            document.head.appendChild(style);
            
            // 更新参数控制面板
            const paramControls = document.getElementById('param-controls');
            paramControls.innerHTML = `
                <h3>实验参数调整</h3>
                
                <!-- 粒子参数 -->
                <div class="mb-4">
                    <h4 class="font-medium mb-2">粒子参数</h4>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="charge" class="text-sm">电荷量 (q)</label>
                            <span id="chargeValue" class="text-xs bg-blue-100 px-2 py-1 rounded">1.0 μC</span>
                        </div>
                        <input type="range" id="charge" min="-10" max="10" step="0.1" value="1" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>-10 μC</span>
                            <span>0</span>
                            <span>+10 μC</span>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="mass" class="text-sm">质量 (m)</label>
                            <span id="massValue" class="text-xs bg-blue-100 px-2 py-1 rounded">1.0 mg</span>
                        </div>
                        <input type="range" id="mass" min="0.1" max="10" step="0.1" value="1" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>0.1 mg</span>
                            <span>5 mg</span>
                            <span>10 mg</span>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="initialVelocity" class="text-sm">初速度 (v₀)</label>
                            <span id="initialVelocityValue" class="text-xs bg-blue-100 px-2 py-1 rounded">5.0 m/s</span>
                        </div>
                        <input type="range" id="initialVelocity" min="0" max="20" step="0.1" value="5" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>0 m/s</span>
                            <span>10 m/s</span>
                            <span>20 m/s</span>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="velocityAngle" class="text-sm">初速度方向 (θ)</label>
                            <span id="velocityAngleValue" class="text-xs bg-blue-100 px-2 py-1 rounded">0°</span>
                        </div>
                        <input type="range" id="velocityAngle" min="0" max="360" step="1" value="0" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>0°</span>
                            <span>180°</span>
                            <span>360°</span>
                        </div>
                    </div>
                </div>
                
                <!-- 电场参数 -->
                <div class="mb-4">
                    <h4 class="font-medium mb-2">电场参数</h4>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="electricField" class="text-sm">电场强度 (E)</label>
                            <span id="electricFieldValue" class="text-xs bg-blue-100 px-2 py-1 rounded">5.0 N/C</span>
                        </div>
                        <input type="range" id="electricField" min="0" max="20" step="0.1" value="5" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>0 N/C</span>
                            <span>10 N/C</span>
                            <span>20 N/C</span>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="fieldAngle" class="text-sm">电场方向 (φ)</label>
                            <span id="fieldAngleValue" class="text-xs bg-blue-100 px-2 py-1 rounded">90°</span>
                        </div>
                        <input type="range" id="fieldAngle" min="0" max="360" step="1" value="90" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>0°</span>
                            <span>180°</span>
                            <span>360°</span>
                        </div>
                    </div>
                </div>
                
                <!-- 模拟控制 -->
                <div class="mb-4">
                    <h4 class="font-medium mb-2">模拟控制</h4>
                    
                    <div class="flex justify-between mb-3">
                        <button id="startBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm">
                            <i class="fa fa-play mr-1"></i>开始
                        </button>
                        <button id="pauseBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm" disabled>
                            <i class="fa fa-pause mr-1"></i>暂停
                        </button>
                        <button id="resetBtn" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">
                            <i class="fa fa-refresh mr-1"></i>重置
                        </button>
                    </div>
                    
                    <div class="mb-3">
                        <div class="flex justify-between mb-1">
                            <label for="simulationSpeed" class="text-sm">模拟速度</label>
                            <span id="simulationSpeedValue" class="text-xs bg-blue-100 px-2 py-1 rounded">1.0x</span>
                        </div>
                        <input type="range" id="simulationSpeed" min="0.1" max="5" step="0.1" value="1" 
                               class="w-full slider-track slider-thumb">
                        <div class="flex justify-between text-xs text-gray-500">
                            <span>0.1x</span>
                            <span>1x</span>
                            <span>5x</span>
                        </div>
                    </div>
                </div>
                
                <button class="start-btn" onclick="runExperiment()">查看实验结果</button>
            `;
            
            // 常量定义
            const MICRO = 1e-6;  // 微库仑转换为库仑
            const MILLI = 1e-6;  // 毫克转换为千克 (1mg = 1e-6kg)
            
            // 获取DOM元素
            const canvas = document.getElementById('simulationCanvas');
            const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const startMessage = document.getElementById('startMessage');
            
            // 获取滑块和显示值的元素
            const sliders = {
                charge: document.getElementById('charge'),
                mass: document.getElementById('mass'),
                initialVelocity: document.getElementById('initialVelocity'),
                velocityAngle: document.getElementById('velocityAngle'),
                electricField: document.getElementById('electricField'),
                fieldAngle: document.getElementById('fieldAngle'),
                simulationSpeed: document.getElementById('simulationSpeed')
            };
            
            const values = {
                chargeValue: document.getElementById('chargeValue'),
                massValue: document.getElementById('massValue'),
                initialVelocityValue: document.getElementById('initialVelocityValue'),
                velocityAngleValue: document.getElementById('velocityAngleValue'),
                electricFieldValue: document.getElementById('electricFieldValue'),
                fieldAngleValue: document.getElementById('fieldAngleValue'),
                simulationSpeedValue: document.getElementById('simulationSpeedValue')
            };
            
            // 调整Canvas大小以匹配容器
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
            
            // 初始化时调整Canvas大小
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 模拟状态
            let simulationState = {
                running: false,
                time: 0,
                timeStep: 0.01,  // 秒
                speedFactor: 1.0,
                particle: {
                    charge: 1e-6,  // 库仑
                    mass: 1e-6,    // 千克
                    position: { x: 0, y: 0 },
                    velocity: { x: 0, y: 0 },
                    acceleration: { x: 0, y: 0 },
                    trail: []
                },
                electricField: {
                    magnitude: 5,  // N/C
                    direction: Math.PI/2  // 弧度
                },
                initialVelocity: {
                    magnitude: 5,  // m/s
                    direction: 0   // 弧度
                },
                boundaries: {
                    left: -10,
                    right: 10,
                    bottom: -10,
                    top: 10
                }
            };
            
            // 更新滑块显示值
            function updateSliderValues() {
                values.chargeValue.textContent = `${sliders.charge.value} μC`;
                values.massValue.textContent = `${sliders.mass.value} mg`;
                values.initialVelocityValue.textContent = `${sliders.initialVelocity.value} m/s`;
                values.velocityAngleValue.textContent = `${sliders.velocityAngle.value}°`;
                values.electricFieldValue.textContent = `${sliders.electricField.value} N/C`;
                values.fieldAngleValue.textContent = `${sliders.fieldAngle.value}°`;
                values.simulationSpeedValue.textContent = `${sliders.simulationSpeed.value}x`;
            }
            
            // 从滑块更新模拟参数
            function updateSimulationParameters() {
                simulationState.particle.charge = parseFloat(sliders.charge.value) * MICRO;
                simulationState.particle.mass = parseFloat(sliders.mass.value) * MILLI;
                
                simulationState.initialVelocity.magnitude = parseFloat(sliders.initialVelocity.value);
                simulationState.initialVelocity.direction = parseFloat(sliders.velocityAngle.value) * Math.PI / 180;
                
                simulationState.electricField.magnitude = parseFloat(sliders.electricField.value);
                simulationState.electricField.direction = parseFloat(sliders.fieldAngle.value) * Math.PI / 180;
                
                simulationState.speedFactor = parseFloat(sliders.simulationSpeed.value);
            }
            
            // 重置模拟
            function resetSimulation() {
                simulationState.running = false;
                simulationState.time = 0;
                
                // 重置粒子位置到原点
                simulationState.particle.position = { x: 0, y: 0 };
                
                // 计算初始速度
                const v0 = simulationState.initialVelocity.magnitude;
                const theta = simulationState.initialVelocity.direction;
                simulationState.particle.velocity = {
                    x: v0 * Math.cos(theta),
                    y: v0 * Math.sin(theta)
                };
                
                // 计算加速度
                const q = simulationState.particle.charge;
                const m = simulationState.particle.mass;
                const E = simulationState.electricField.magnitude;
                const phi = simulationState.electricField.direction;
                
                // 电场力 F = qE
                const Fx = q * E * Math.cos(phi);
                const Fy = q * E * Math.sin(phi);
                
                // 加速度 a = F/m
                simulationState.particle.acceleration = {
                    x: Fx / m,
                    y: Fy / m
                };
                
                // 清空轨迹
                simulationState.particle.trail = [];
                
                // 更新UI状态
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                startMessage.style.display = 'block';
                
                // 绘制初始状态
                drawSimulation();
            }
            
            // 更新模拟
            function updateSimulation() {
                if (!simulationState.running) return;
                
                // 增加时间
                const dt = simulationState.timeStep * simulationState.speedFactor;
                simulationState.time += dt;
                
                // 获取当前状态
                const x = simulationState.particle.position.x;
                const y = simulationState.particle.position.y;
                const vx = simulationState.particle.velocity.x;
                const vy = simulationState.particle.velocity.y;
                const ax = simulationState.particle.acceleration.x;
                const ay = simulationState.particle.acceleration.y;
                
                // 更新速度 (v = v0 + a*t)
                const newVx = vx + ax * dt;
                const newVy = vy + ay * dt;
                
                // 更新位置 (s = s0 + v0*t + 0.5*a*t²)
                const newX = x + vx * dt + 0.5 * ax * dt * dt;
                const newY = y + vy * dt + 0.5 * ay * dt * dt;
                
                // 检查边界碰撞
                const boundaries = simulationState.boundaries;
                let bounced = false;
                
                if (newX < boundaries.left || newX > boundaries.right) {
                    simulationState.particle.velocity.x = -newVx * 0.8;  // 反弹，能量损失
                    simulationState.particle.velocity.y = newVy * 0.8;
                    bounced = true;
                } else {
                    simulationState.particle.position.x = newX;
                    simulationState.particle.velocity.x = newVx;
                }
                
                if (newY < boundaries.bottom || newY > boundaries.top) {
                    simulationState.particle.velocity.y = -newVy * 0.8;  // 反弹，能量损失
                    simulationState.particle.velocity.x = newVx * 0.8;
                    bounced = true;
                } else {
                    simulationState.particle.position.y = newY;
                    simulationState.particle.velocity.y = newVy;
                }
                
                // 如果没有碰撞，记录轨迹点
                if (!bounced) {
                    simulationState.particle.trail.push({x: newX, y: newY});
                    
                    // 限制轨迹点数量，避免内存占用过大
                    if (simulationState.particle.trail.length > 500) {
                        simulationState.particle.trail.shift();
                    }
                }
                
                // 更新实时数据显示
                updateDataDisplay();
                
                // 绘制模拟
                drawSimulation();
                
                // 继续下一帧
                requestAnimationFrame(updateSimulation);
            }
            
            // 更新实时数据显示
            function updateDataDisplay() {
                const particle = simulationState.particle;
                
                // 计算位置
                const posX = particle.position.x.toFixed(2);
                const posY = particle.position.y.toFixed(2);
                
                // 计算速度大小和方向
                const vx = particle.velocity.x;
                const vy = particle.velocity.y;
                const vMag = Math.sqrt(vx*vx + vy*vy);
                const vDir = Math.atan2(vy, vx) * 180 / Math.PI;
                
                // 计算加速度大小和方向
                const ax = particle.acceleration.x;
                const ay = particle.acceleration.y;
                const aMag = Math.sqrt(ax*ax + ay*ay);
                const aDir = Math.atan2(ay, ax) * 180 / Math.PI;
                
                // 更新DOM元素
                document.getElementById('position').textContent = `x: ${posX} m, y: ${posY} m`;
                document.getElementById('velocity').textContent = `${vMag.toFixed(2)} m/s, ${Math.round(vDir)}°`;
                document.getElementById('acceleration').textContent = `${aMag.toFixed(2)} m/s², ${Math.round(aDir)}°`;
            }
            
            // 绘制模拟
            function drawSimulation() {
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 获取画布中心和缩放比例
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / (2 * Math.max(
                    Math.abs(simulationState.boundaries.right - simulationState.boundaries.left),
                    Math.abs(simulationState.boundaries.top - simulationState.boundaries.bottom)
                ));
                
                // 绘制网格
                drawGrid(centerX, centerY, scale);
                
                // 绘制电场
                drawElectricField(centerX, centerY, scale);
                
                // 绘制粒子轨迹
                drawTrail(centerX, centerY, scale);
                
                // 绘制粒子
                drawParticle(centerX, centerY, scale);
                
                // 绘制坐标轴
                drawCoordinateSystem(centerX, centerY, scale);
            }
            
            // 绘制网格
            function drawGrid(centerX, centerY, scale) {
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                
                const boundaries = simulationState.boundaries;
                const gridSize = 1;  // 网格大小为1米
                
                // 绘制垂直线
                for (let x = Math.ceil(boundaries.left / gridSize) * gridSize; x <= boundaries.right; x += gridSize) {
                    const screenX = centerX + x * scale;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvas.height);
                    ctx.stroke();
                    
                    // 绘制坐标标签
                    if (x !== 0) {
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(x.toString(), screenX, centerY + 15);
                    }
                }
                
                // 绘制水平线
                for (let y = Math.ceil(boundaries.bottom / gridSize) * gridSize; y <= boundaries.top; y += gridSize) {
                    const screenY = centerY - y * scale;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvas.width, screenY);
                    ctx.stroke();
                    
                    // 绘制坐标标签
                    if (y !== 0) {
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'right';
                        ctx.fillText(y.toString(), centerX - 5, screenY + 4);
                    }
                }
            }
            
            // 绘制坐标系
            function drawCoordinateSystem(centerX, centerY, scale) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                
                // X轴
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.stroke();
                
                // Y轴
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                // 绘制坐标轴箭头
                const arrowSize = 10;
                
                // X轴箭头
                ctx.beginPath();
                ctx.moveTo(canvas.width - arrowSize, centerY - arrowSize / 2);
                ctx.lineTo(canvas.width, centerY);
                ctx.lineTo(canvas.width - arrowSize, centerY + arrowSize / 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                
                // Y轴箭头
                ctx.beginPath();
                ctx.moveTo(centerX - arrowSize / 2, arrowSize);
                ctx.lineTo(centerX, 0);
                ctx.lineTo(centerX + arrowSize / 2, arrowSize);
                ctx.fill();
                
                // 绘制坐标轴标签
                ctx.font = '16px Arial';
                ctx.fillStyle = '#000';
                
                // X轴标签
                ctx.textAlign = 'center';
                ctx.fillText('X (m)', canvas.width - 20, centerY + 25);
                
                // Y轴标签
                ctx.textAlign = 'left';
                ctx.fillText('Y (m)', centerX + 10, 20);
            }
            
            // 绘制电场
            function drawElectricField(centerX, centerY, scale) {
                const E = simulationState.electricField.magnitude;
                const phi = simulationState.electricField.direction;
                
                if (E === 0) return;
                
                // 电场线密度
                const lineSpacing = 1.5;
                const numLines = Math.floor(E * 2);
                
                // 电场线颜色
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                
                // 电场线箭头大小
                const arrowSize = 8;
                
                // 计算电场方向的单位向量
                const ex = Math.cos(phi);
                const ey = Math.sin(phi);
                
                // 计算垂直于电场方向的单位向量
                const nx = -ey;
                const ny = ex;
                
                // 绘制电场线
                for (let i = -numLines; i <= numLines; i++) {
                    // 计算电场线的起始位置
                    const offset = i * lineSpacing;
                    const startX = simulationState.boundaries.left + 0.5;
                    const startY = 0 + offset * ny;
                    
                    // 转换为屏幕坐标
                    let screenX = centerX + startX * scale;
                    let screenY = centerY - startY * scale;
                    
                    // 绘制电场线
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    
                    // 沿电场方向绘制线段
                    const length = simulationState.boundaries.right - simulationState.boundaries.left - 1;
                    const endX = startX + length * ex;
                    const endY = startY + length * ey;
                    
                    // 转换为屏幕坐标
                    const screenEndX = centerX + endX * scale;
                    const screenEndY = centerY - endY * scale;
                    
                    ctx.lineTo(screenEndX, screenEndY);
                    ctx.stroke();
                    
                    // 绘制箭头
                    const arrowX = startX + length * 0.7 * ex;
                    const arrowY = startY + length * 0.7 * ey;
                    const screenArrowX = centerX + arrowX * scale;
                    const screenArrowY = centerY - arrowY * scale;
                    
                    // 计算箭头方向
                    const angle = Math.atan2(screenEndY - screenArrowY, screenEndX - screenArrowX);
                    
                    ctx.beginPath();
                    ctx.moveTo(screenArrowX, screenArrowY);
                    ctx.lineTo(
                        screenArrowX - arrowSize * Math.cos(angle - Math.PI / 6),
                        screenArrowY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        screenArrowX - arrowSize * Math.cos(angle + Math.PI / 6),
                        screenArrowY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = '#3b82f6';
                    ctx.fill();
                }
                
                // 绘制电场强度标签
                ctx.font = '16px Arial';
                ctx.fillStyle = '#3b82f6';
                ctx.textAlign = 'center';
                
                const labelX = centerX + (simulationState.boundaries.right - 2) * scale;
                const labelY = centerY - (simulationState.boundaries.top - 2) * scale;
                
                ctx.fillText(`E = ${E.toFixed(1)} N/C`, labelX, labelY);
            }
            
            // 绘制粒子轨迹
            function drawTrail(centerX, centerY, scale) {
                const trail = simulationState.particle.trail;
                
                if (trail.length < 2) return;
                
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                
                // 转换第一个点的坐标
                const firstPoint = trail[0];
                const screenX = centerX + firstPoint.x * scale;
                const screenY = centerY - firstPoint.y * scale;
                
                ctx.moveTo(screenX, screenY);
                
                // 绘制轨迹线
                for (let i = 1; i < trail.length; i++) {
                    const point = trail[i];
                    const screenX = centerX + point.x * scale;
                    const screenY = centerY - point.y * scale;
                    ctx.lineTo(screenX, screenY);
                }
                
                ctx.stroke();
            }
            
            // 绘制粒子
            function drawParticle(centerX, centerY, scale) {
                const x = simulationState.particle.position.x;
                const y = simulationState.particle.position.y;
                const charge = simulationState.particle.charge;
                
                // 转换为屏幕坐标
                const screenX = centerX + x * scale;
                const screenY = centerY - y * scale;
                
                // 根据电荷正负设置颜色
                const color = charge > 0 ? '#ef4444' : '#3b82f6';
                
                // 绘制粒子
                const radius = 8;
                ctx.beginPath();
                ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                // 绘制电荷符号
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(charge > 0 ? '+' : '−', screenX, screenY);
                
                // 绘制速度向量
                const vx = simulationState.particle.velocity.x;
                const vy = simulationState.particle.velocity.y;
                const vMag = Math.sqrt(vx*vx + vy*vy);
                
                if (vMag > 0.1) {
                    const arrowLength = Math.min(vMag * 0.5, 50);
                    const vxNorm = vx / vMag;
                    const vyNorm = vy / vMag;
                    
                    const arrowEndX = screenX + vxNorm * arrowLength;
                    const arrowEndY = screenY - vyNorm * arrowLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY);
                    ctx.lineTo(arrowEndX, arrowEndY);
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 绘制速度箭头
                    const arrowSize = 8;
                    const angle = Math.atan2(arrowEndY - screenY, arrowEndX - screenX);
                    
                    ctx.beginPath();
                    ctx.moveTo(arrowEndX, arrowEndY);
                    ctx.lineTo(
                        arrowEndX - arrowSize * Math.cos(angle - Math.PI / 6),
                        arrowEndY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        arrowEndX - arrowSize * Math.cos(angle + Math.PI / 6),
                        arrowEndY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = '#22c55e';
                    ctx.fill();
                    
                    // 绘制速度标签
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#22c55e';
                    ctx.textAlign = 'center';
                    ctx.fillText('v', (screenX + arrowEndX) / 2, (screenY + arrowEndY) / 2 - 10);
                }
            }
            
            // 事件监听器
            startBtn.addEventListener('click', function() {
                simulationState.running = true;
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                startMessage.style.display = 'none';
                updateSimulation();
            });
            
            pauseBtn.addEventListener('click', function() {
                simulationState.running = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
            });
            
            resetBtn.addEventListener('click', function() {
                updateSimulationParameters();
                resetSimulation();
            });
            
            // 滑块事件监听器
            Object.keys(sliders).forEach(key => {
                sliders[key].addEventListener('input', function() {
                    updateSliderValues();
                    
                    // 如果模拟未运行，更新参数并重置
                    if (!simulationState.running) {
                        updateSimulationParameters();
                        resetSimulation();
                    } else if (key === 'simulationSpeed') {
                        // 如果是模拟速度滑块，实时更新
                        simulationState.speedFactor = parseFloat(sliders.simulationSpeed.value);
                    }
                });
            });
            
            // 初始化
            updateSliderValues();
            updateSimulationParameters();
            resetSimulation();
        }
        
        // ===== 平行板电容器电容影响因素实验 =====
        function initCapacitorExperiment() {
            // 创建实验所需的HTML结构
            const container = document.getElementById('capacitor-container');
            container.innerHTML = `
                <div class="flex flex-col h-full">
                    <div class="flex-1 relative">
                        <canvas id="capacitor-canvas" class="w-full h-full"></canvas>
                        <div id="canvas-tooltip" class="absolute bg-neutral-dark text-white text-xs rounded py-1 px-2 -mt-8 opacity-0 transition-opacity duration-300">
                            提示信息
                        </div>
                        <!-- 实时数据显示面板 -->
                        <div id="capacitorDataPanel" class="absolute bottom-0 left-0 w-full bg-white bg-opacity-90 p-3 shadow-lg rounded-t-lg">
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>
                                    <span class="font-bold">电容:</span>
                                    <span id="capacitanceValue">0.00 pF</span>
                                </div>
                                <div>
                                    <span class="font-bold">电场强度:</span>
                                    <span id="fieldValue">0.00 V/m</span>
                                </div>
                                <div>
                                    <span class="font-bold">电荷量:</span>
                                    <span id="chargeValue">0.00 pC</span>
                                </div>
                                <div>
                                    <span class="font-bold">粒子速度:</span>
                                    <span id="particleVelocity">0.00 m/s</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- 公式和原理解释区域 -->
                    <div class="bg-white p-3 mt-2 rounded-lg shadow">
                        <h4 class="font-bold mb-2">平行板电容器原理:</h4>
                        <div class="grid grid-cols-1 gap-2 text-sm">
                            <div><strong>电容公式:</strong> C = ε₀εᵣS/d</div>
                            <div><strong>其中:</strong> ε₀=8.85×10⁻¹² F/m (真空介电常数)</div>
                            <div><strong>影响因素:</strong></div>
                            <div>• 极板面积S增大 → 电容C增大</div>
                            <div>• 极板间距d增大 → 电容C减小</div>
                            <div>• 介电常数εᵣ增大 → 电容C增大</div>
                            <div><strong>电场强度:</strong> E = U/d</div>
                            <div><strong>电荷量:</strong> Q = CU</div>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加Tailwind CSS和Font Awesome（如果尚未添加）
            if (!document.getElementById('tailwind-css')) {
                const tailwindScript = document.createElement('script');
                tailwindScript.id = 'tailwind-css';
                tailwindScript.src = 'https://cdn.tailwindcss.com';
                document.head.appendChild(tailwindScript);
            }
            
            if (!document.getElementById('font-awesome')) {
                const fontAwesomeLink = document.createElement('link');
                fontAwesomeLink.id = 'font-awesome';
                fontAwesomeLink.href = 'https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css';
                fontAwesomeLink.rel = 'stylesheet';
                document.head.appendChild(fontAwesomeLink);
            }
            
            // 添加Chart.js（如果尚未添加）
            if (!document.getElementById('chart-js')) {
                const chartScript = document.createElement('script');
                chartScript.id = 'chart-js';
                chartScript.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js';
                document.head.appendChild(chartScript);
            }
            
            // 添加自定义样式
            const style = document.createElement('style');
            style.textContent = `
                .text-shadow {
                    text-shadow: 0 2px 4px rgba(0,0,0,0.1);
                }
                .transition-all-300 {
                    transition: all 300ms ease-in-out;
                }
                .slider-thumb::-webkit-slider-thumb {
                    appearance: none;
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    background: #1e40af;
                    border: 2px solid white;
                    cursor: pointer;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                }
                .slider-track {
                    appearance: none;
                    height: 8px;
                    border-radius: 4px;
                    background: #dbeafe;
                }
                .formula-highlight {
                    color: #1e40af;
                    font-weight: bold;
                    transition: all 300ms ease-in-out;
                }
                .electric-field-line {
                    stroke-dasharray: 5;
                    animation: dash 1s linear infinite;
                }
                @keyframes dash {
                    to {
                        stroke-dashoffset: -10;
                    }
                }
                .particle {
                    transition: transform 0.1s linear;
                }
                .tooltip {
                    visibility: hidden;
                    position: absolute;
                    background-color: #334155;
                    color: white;
                    text-align: center;
                    border-radius: 4px;
                    padding: 4px 8px;
                    position: absolute;
                    z-index: 1;
                    opacity: 0;
                    transition: opacity 300ms;
                    width: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                }
                .has-tooltip:hover .tooltip {
                    visibility: visible;
                    opacity: 1;
                }
            `;
            document.head.appendChild(style);
            
            // 更新参数控制面板
            const paramControls = document.getElementById('param-controls');
            paramControls.innerHTML = `
                <h3>实验参数调整</h3>
                
                <!-- 极板间距调节 -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label for="distance" class="text-sm">极板间距 (d)</label>
                        <span id="distance-value" class="bg-blue-100 px-2 py-1 rounded text-primary text-xs">5 mm</span>
                    </div>
                    <input type="range" id="distance" min="1" max="10" value="5" step="0.1" 
                           class="w-full slider-track slider-thumb">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>1 mm</span>
                        <span>10 mm</span>
                    </div>
                </div>
                
                <!-- 极板面积调节 -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label for="area" class="text-sm">极板面积 (S)</label>
                        <span id="area-value" class="bg-blue-100 px-2 py-1 rounded text-primary text-xs">100 mm²</span>
                    </div>
                    <input type="range" id="area" min="50" max="200" value="100" step="1" 
                           class="w-full slider-track slider-thumb">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>50 mm²</span>
                        <span>200 mm²</span>
                    </div>
                </div>
                
                <!-- 介电常数调节 -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label for="dielectric" class="text-sm">介电常数 (εᵣ)</label>
                        <span id="dielectric-value" class="bg-blue-100 px-2 py-1 rounded text-primary text-xs">1</span>
                    </div>
                    <input type="range" id="dielectric" min="1" max="10" value="1" step="0.1" 
                           class="w-full slider-track slider-thumb">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>1 (真空)</span>
                        <span>10 (高介电材料)</span>
                    </div>
                </div>
                
                <!-- 电压调节 -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label for="voltage" class="text-sm">电压 (U)</label>
                        <span id="voltage-value" class="bg-blue-100 px-2 py-1 rounded text-primary text-xs">5 V</span>
                    </div>
                    <input type="range" id="voltage" min="1" max="10" value="5" step="0.1" 
                           class="w-full slider-track slider-thumb">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>1 V</span>
                        <span>10 V</span>
                    </div>
                </div>
                
                <!-- 粒子类型选择 -->
                <div class="mb-4">
                    <label class="text-sm block mb-2">粒子类型</label>
                    <div class="flex gap-2">
                        <label class="inline-flex items-center text-xs">
                            <input type="radio" name="particle-type" value="electron" checked 
                                   class="form-radio text-primary focus:ring-primary">
                            <span class="ml-1">电子 (负电荷)</span>
                        </label>
                        <label class="inline-flex items-center text-xs">
                            <input type="radio" name="particle-type" value="proton" 
                                   class="form-radio text-primary focus:ring-primary">
                            <span class="ml-1">质子 (正电荷)</span>
                        </label>
                    </div>
                </div>
                
                <!-- 控制按钮 -->
                <div class="flex gap-2 mb-4">
                    <button id="start-btn" class="flex-1 bg-primary hover:bg-blue-700 text-white text-xs py-2 px-3 rounded transition-all-300 flex items-center justify-center">
                        <i class="fa fa-play mr-1"></i> 开始演示
                    </button>
                    <button id="reset-btn" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 text-xs py-2 px-3 rounded transition-all-300 flex items-center justify-center">
                        <i class="fa fa-refresh mr-1"></i> 重置
                    </button>
                </div>
                
                <button class="start-btn" onclick="runExperiment()">查看实验结果</button>
            `;
            
            // 等待Chart.js加载完成
            function waitForChartJs() {
                if (typeof Chart !== 'undefined') {
                    initCapacitorSimulation();
                } else {
                    setTimeout(waitForChartJs, 100);
                }
            }
            
            // 初始化电容器模拟
            function initCapacitorSimulation() {
                // 常量定义
                const COULOMB_CONSTANT = 8.988e9; // 静电力常数 (N·m²/C²)
                const VACUUM_PERMITTIVITY = 8.854e-12; // 真空介电常数 (F/m)
                const ELECTRON_CHARGE = -1.602e-19; // 电子电荷 (C)
                const PROTON_CHARGE = 1.602e-19; // 质子电荷 (C)
                const ELECTRON_MASS = 9.109e-31; // 电子质量 (kg)
                const PROTON_MASS = 1.673e-27; // 质子质量 (kg)
                
                // 获取DOM元素
                const distanceSlider = document.getElementById('distance');
                const distanceValue = document.getElementById('distance-value');
                const areaSlider = document.getElementById('area');
                const areaValue = document.getElementById('area-value');
                const dielectricSlider = document.getElementById('dielectric');
                const dielectricValue = document.getElementById('dielectric-value');
                const voltageSlider = document.getElementById('voltage');
                const voltageValue = document.getElementById('voltage-value');
                const startBtn = document.getElementById('start-btn');
                const resetBtn = document.getElementById('reset-btn');
                const particleTypeRadios = document.getElementsByName('particle-type');
                const capacitorCanvas = document.getElementById('capacitor-canvas');
                const ctx = capacitorCanvas.getContext('2d');
                const canvasTooltip = document.getElementById('canvas-tooltip');
                
                // 调整Canvas大小
                function resizeCanvas() {
                    const container = capacitorCanvas.parentElement;
                    capacitorCanvas.width = container.clientWidth;
                    capacitorCanvas.height = container.clientHeight;
                }
                
                // 初始化时调整Canvas大小
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // 模拟数据
                let simulationState = {
                    distance: parseFloat(distanceSlider.value), // 极板间距 (mm)
                    area: parseFloat(areaSlider.value), // 极板面积 (mm²)
                    dielectric: parseFloat(dielectricSlider.value), // 介电常数
                    voltage: parseFloat(voltageSlider.value), // 电压 (V)
                    particleType: 'electron', // 粒子类型
                    isRunning: false, // 是否正在运行
                    particle: {
                        x: 0,
                        y: 0,
                        vx: 0,
                        vy: 0,
                        ax: 0,
                        ay: 0,
                        charge: ELECTRON_CHARGE,
                        mass: ELECTRON_MASS,
                        radius: 5
                    },
                    timeStep: 0.01, // 时间步长 (s)
                    time: 0, // 模拟时间 (s)
                    capacitanceHistory: [], // 电容历史记录
                    fieldHistory: [] // 电场强度历史记录
                };
                
                // 计算电容
                function calculateCapacitance() {
                    // 转换单位：mm -> m, mm² -> m²
                    const distanceM = simulationState.distance / 1000;
                    const areaM2 = simulationState.area / 1e6;
                    
                    // 电容公式：C = ε₀ * εᵣ * S / d
                    const capacitance = VACUUM_PERMITTIVITY * simulationState.dielectric * areaM2 / distanceM;
                    return capacitance;
                }
                
                // 计算电场强度
                function calculateElectricField() {
                    // 电场强度：E = U / d
                    const distanceM = simulationState.distance / 1000;
                    return simulationState.voltage / distanceM;
                }
                
                // 计算电荷量
                function calculateCharge() {
                    const capacitance = calculateCapacitance();
                    return capacitance * simulationState.voltage;
                }
                
                // 更新UI显示
                function updateUI() {
                    distanceValue.textContent = `${simulationState.distance.toFixed(1)} mm`;
                    areaValue.textContent = `${simulationState.area.toFixed(0)} mm²`;
                    dielectricValue.textContent = simulationState.dielectric.toFixed(1);
                    voltageValue.textContent = `${simulationState.voltage.toFixed(1)} V`;
                }
                
                // 科学计数法格式化
                function formatScientific(value) {
                    if (value === 0) return '0';
                    
                    const exponent = Math.floor(Math.log10(Math.abs(value)));
                    const mantissa = value / Math.pow(10, exponent);
                    
                    return mantissa.toFixed(2) + ' × 10' + superscript(exponent);
                }
                
                // 将数字转换为上标
                function superscript(num) {
                    const digits = {
                        '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', 
                        '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹',
                        '-': '⁻'
                    };
                    
                    return num.toString().split('').map(char => digits[char] || char).join('');
                }
                
                // 初始化粒子
                function initParticle() {
                    const canvasWidth = capacitorCanvas.width;
                    const canvasHeight = capacitorCanvas.height;
                    
                    // 极板间距（像素）
                    const plateDistancePx = canvasWidth * 0.6;
                    
                    // 粒子初始位置在左极板附近
                    simulationState.particle.x = canvasWidth * 0.2 + Math.random() * 20;
                    simulationState.particle.y = canvasHeight / 2 + (Math.random() - 0.5) * 40;
                    
                    // 初始速度
                    simulationState.particle.vx = 0;
                    simulationState.particle.vy = 0;
                    
                    // 根据选择的粒子类型设置电荷和质量
                    if (simulationState.particleType === 'electron') {
                        simulationState.particle.charge = ELECTRON_CHARGE;
                        simulationState.particle.mass = ELECTRON_MASS;
                    } else {
                        simulationState.particle.charge = PROTON_CHARGE;
                        simulationState.particle.mass = PROTON_MASS;
                    }
                }
                
                // 更新粒子状态
                function updateParticle() {
                    if (!simulationState.isRunning) return;
                    
                    const electricField = calculateElectricField();
                    
                    // 计算电场力：F = q * E
                    const force = simulationState.particle.charge * electricField;
                    
                    // 计算加速度：a = F / m
                    simulationState.particle.ax = force / simulationState.particle.mass;
                    simulationState.particle.ay = 0; // 假设只有x方向的电场
                    
                    // 更新速度：v = v0 + a * t
                    simulationState.particle.vx += simulationState.particle.ax * simulationState.timeStep;
                    simulationState.particle.vy += simulationState.particle.ay * simulationState.timeStep;
                    
                    // 更新位置：x = x0 + v * t
                    simulationState.particle.x += simulationState.particle.vx * simulationState.timeStep;
                    simulationState.particle.y += simulationState.particle.vy * simulationState.timeStep;
                    
                    // 检查是否到达右极板
                    const canvasWidth = capacitorCanvas.width;
                    if (simulationState.particle.x > canvasWidth * 0.8) {
                        simulationState.isRunning = false;
                        startBtn.innerHTML = '<i class="fa fa-play mr-1"></i> 开始演示';
                    }
                    
                    // 更新时间
                    simulationState.time += simulationState.timeStep;
                }
                
                // 绘制电容器
                function drawCapacitor() {
                    const canvasWidth = capacitorCanvas.width;
                    const canvasHeight = capacitorCanvas.height;
                    
                    // 清空画布
                    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    
                    // 根据参数调整极板尺寸和位置
                    // 极板间距随distance参数变化
                    const minDistance = 0.2 * canvasWidth;
                    const maxDistance = 0.7 * canvasWidth;
                    const plateDistance = minDistance + (maxDistance - minDistance) * 
                                        (simulationState.distance - 1) / 9; // distance范围1-10
                    
                    // 极板面积随area参数变化
                    const minArea = 0.4 * canvasHeight;
                    const maxArea = 0.8 * canvasHeight;
                    const plateWidth = minArea + (maxArea - minArea) * 
                                    (simulationState.area - 50) / 150; // area范围50-200
                    
                    const plateHeight = 10;
                    const plateX1 = (canvasWidth - plateDistance) / 2; // 左极板x坐标
                    const plateX2 = plateX1 + plateDistance; // 右极板x坐标
                    const plateY = canvasHeight / 2; // 极板y坐标
                    
                    // 绘制左极板（负极）
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillRect(plateX1 - plateHeight / 2, plateY - plateWidth / 2, plateHeight, plateWidth);
                    
                    // 绘制右极板（正极）
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(plateX2 - plateHeight / 2, plateY - plateWidth / 2, plateHeight, plateWidth);
                    
                    // 绘制极板标签
                    ctx.fillStyle = '#1e40af';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('-', plateX1, plateY - plateWidth / 2 - 10);
                    
                    ctx.fillStyle = '#b91c1c';
                    ctx.fillText('+', plateX2, plateY - plateWidth / 2 - 10);
                    
                    // 绘制电场线
                    drawElectricFieldLines(plateX1, plateX2, plateY, plateWidth);
                    
                    // 绘制粒子
                    drawParticle();
                    
                    // 绘制极板间距标签
                    ctx.fillStyle = '#334155';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`d = ${simulationState.distance.toFixed(1)} mm`, 
                               (plateX1 + plateX2) / 2, plateY + plateWidth / 2 + 20);
                    
                    // 绘制极板面积标签
                    ctx.fillStyle = '#334155';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`S = ${simulationState.area.toFixed(0)} mm²`, 
                               plateX1 - 20, plateY);
                    
                    // 绘制介电常数标签
                    ctx.fillStyle = '#334155';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(`εᵣ = ${simulationState.dielectric.toFixed(1)}`, 
                               plateX2 + 20, plateY);
                    
                    // 绘制电压标签
                    ctx.fillStyle = '#334155';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${simulationState.voltage.toFixed(1)} V`, canvasWidth / 2, plateY - plateWidth / 2 - 10);
                    
                    // 更新实时数据显示
                    updateDataDisplay();
                }
                
                // 更新实时数据显示
                function updateDataDisplay() {
                    const capacitance = calculateCapacitance();
                    const electricField = calculateElectricField();
                    const charge = calculateCharge();
                    const particle = simulationState.particle;
                    
                    // 计算粒子速度大小
                    const vx = particle.vx;
                    const vy = particle.vy;
                    const vMag = Math.sqrt(vx*vx + vy*vy);
                    
                    // 更新DOM元素
                    document.getElementById('capacitanceValue').textContent = `${(capacitance * 1e12).toFixed(2)} pF`;
                    document.getElementById('fieldValue').textContent = `${electricField.toFixed(2)} V/m`;
                    document.getElementById('chargeValue').textContent = `${(charge * 1e12).toFixed(2)} pC`;
                    document.getElementById('particleVelocity').textContent = `${vMag.toFixed(2)} m/s`;
                }
                
                // 绘制电场线
                function drawElectricFieldLines(plateX1, plateX2, plateY, plateWidth) {
                    const numLines = 10;
                    const lineSpacing = plateWidth / numLines;
                    
                    ctx.strokeStyle = '#60a5fa';
                    ctx.lineWidth = 1;
                    
                    for (let i = 1; i < numLines; i++) {
                        const y = plateY - plateWidth / 2 + i * lineSpacing;
                        
                        ctx.beginPath();
                        ctx.moveTo(plateX1, y);
                        ctx.lineTo(plateX2, y);
                        ctx.stroke();
                        
                        // 绘制箭头
                        const arrowX = plateX1 + (plateX2 - plateX1) * 0.7;
                        drawArrow(arrowX, y, 0);
                    }
                }
                
                // 绘制箭头
                function drawArrow(x, y, angle) {
                    const arrowSize = 5;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-arrowSize, -arrowSize / 2);
                    ctx.lineTo(-arrowSize, arrowSize / 2);
                    ctx.closePath();
                    
                    ctx.fillStyle = '#60a5fa';
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // 绘制粒子
                function drawParticle() {
                    const particle = simulationState.particle;
                    
                    // 根据粒子类型设置颜色
                    ctx.fillStyle = particle.charge < 0 ? '#3b82f6' : '#ef4444';
                    
                    // 绘制粒子
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制粒子轨迹
                    if (simulationState.isRunning && simulationState.time > 0.1) {
                        ctx.strokeStyle = particle.charge < 0 ? 'rgba(59, 130, 246, 0.3)' : 'rgba(239, 68, 68, 0.3)';
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.moveTo(particle.x - particle.vx * simulationState.timeStep, 
                                   particle.y - particle.vy * simulationState.timeStep);
                        ctx.lineTo(particle.x, particle.y);
                        ctx.stroke();
                    }
                }
                
                // 动画循环
                function animate() {
                    updateParticle();
                    drawCapacitor();
                    
                    if (simulationState.isRunning) {
                        requestAnimationFrame(animate);
                    }
                }
                
                // 事件监听器
                distanceSlider.addEventListener('input', function() {
                    simulationState.distance = parseFloat(this.value);
                    updateUI();
                    drawCapacitor();
                });
                
                areaSlider.addEventListener('input', function() {
                    simulationState.area = parseFloat(this.value);
                    updateUI();
                    drawCapacitor();
                });
                
                dielectricSlider.addEventListener('input', function() {
                    simulationState.dielectric = parseFloat(this.value);
                    updateUI();
                    drawCapacitor();
                });
                
                voltageSlider.addEventListener('input', function() {
                    simulationState.voltage = parseFloat(this.value);
                    updateUI();
                    drawCapacitor();
                });
                
                // 粒子类型选择
                for (let radio of particleTypeRadios) {
                    radio.addEventListener('change', function() {
                        simulationState.particleType = this.value;
                        
                        // 如果模拟正在运行，先停止
                        if (simulationState.isRunning) {
                            simulationState.isRunning = false;
                            startBtn.innerHTML = '<i class="fa fa-play mr-1"></i> 开始演示';
                        }
                        
                        initParticle();
                        drawCapacitor();
                    });
                }
                
                // 开始/暂停按钮
                startBtn.addEventListener('click', function() {
                    if (simulationState.isRunning) {
                        simulationState.isRunning = false;
                        this.innerHTML = '<i class="fa fa-play mr-1"></i> 开始演示';
                    } else {
                        simulationState.isRunning = true;
                        this.innerHTML = '<i class="fa fa-pause mr-1"></i> 暂停演示';
                        animate();
                    }
                });
                
                // 重置按钮
                resetBtn.addEventListener('click', function() {
                    // 重置参数
                    distanceSlider.value = 5;
                    areaSlider.value = 100;
                    dielectricSlider.value = 1;
                    voltageSlider.value = 5;
                    
                    simulationState.distance = 5;
                    simulationState.area = 100;
                    simulationState.dielectric = 1;
                    simulationState.voltage = 5;
                    simulationState.isRunning = false;
                    simulationState.time = 0;
                    
                    // 重置粒子
                    initParticle();
                    
                    // 更新UI
                    updateUI();
                    drawCapacitor();
                    
                    // 更新按钮状态
                    startBtn.innerHTML = '<i class="fa fa-play mr-1"></i> 开始演示';
                });
                
                // 初始化
                function init() {
                    initParticle();
                    updateUI();
                    drawCapacitor();
                }
                
                // 初始化模拟
                init();
            }
            
            // 等待Chart.js加载
            waitForChartJs();
        }
        
        // ===== 点电荷电场可视化 =====
        function initPointChargeScene() {
            console.log('Initializing point charge scene...');
            
            // 全局变量
            let scene, camera, renderer, controls;
            let fieldLines = [];
            let charges = [];
            let gridHelper, axesHelper;
            let heatmapMesh;
            let vectorField = [];
            
            // 电场线参数
            let fieldLineParams = {
                density: 32,
                length: 200,
                step: 0.03
            };
            
            // 物理参数
            let physicsParams = {
                k: 8.99e9 // 库仑常数
            };
            
            // 显示选项
            let displayOptions = {
                fieldLines: true,
                heatmap: false,
                vectors: false,
                grid: true
            };
            
            // 初始化函数
            function init() {
                console.log('Initializing Three.js scene...');
                
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a1128);
                
                // 创建相机
                const container = document.getElementById('scene-container');
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(5, 5, 5);
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                container.appendChild(renderer.domElement);
                
                // 添加轨道控制器
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // 添加光源
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);
                
                // 添加网格和坐标轴
                gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                axesHelper = new THREE.AxesHelper(10);
                scene.add(axesHelper);
                
                // 添加默认电荷
                addCharge(0, 0, 0, 1);
                
                // 计算并绘制电场线
                calculateAndDrawFieldLines();
                
                // 添加窗口大小调整事件
                window.addEventListener('resize', onWindowResize);
                
                // 初始化控制面板事件
                initControlPanel();
                
                // 开始动画循环
                animate();
                
                console.log('Three.js scene initialized');
            }
            
            // 窗口大小调整事件处理函数
            function onWindowResize() {
                const container = document.getElementById('scene-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                // 更新控制器
                controls.update();
                
                // 渲染场景
                renderer.render(scene, camera);
            }
            
            // 添加电荷
            function addCharge(x, y, z, q, isFixed = false) {
                // 创建电荷几何体
                const geometry = new THREE.SphereGeometry(0.3, 32, 32);
                
                // 根据电荷量确定颜色
                const material = new THREE.MeshPhongMaterial({ 
                    color: q > 0 ? 0x0694a2 : 0xe02424,
                    emissive: q > 0 ? 0x0a4a52 : 0x8a1a1a,
                    specular: 0xffffff,
                    shininess: 100
                });
                
                // 创建电荷网格
                const charge = new THREE.Mesh(geometry, material);
                charge.position.set(x, y, z);
                charge.castShadow = true;
                charge.receiveShadow = false;
                
                // 添加到场景
                scene.add(charge);
                
                // 创建电荷标签
                const sign = q > 0 ? '+' : '-';
                const magnitude = Math.abs(q).toFixed(1);
                
                // 创建电荷对象
                const chargeObj = {
                    mesh: charge,
                    q: q,
                    position: new THREE.Vector3(x, y, z),
                    isFixed: isFixed,
                    magnitude: magnitude
                };
                
                // 添加到电荷列表
                charges.push(chargeObj);
                
                // 添加到控制面板
                addChargeControl(chargeObj, charges.length - 1);
                
                return chargeObj;
            }
            
            // 添加电荷控制面板
            function addChargeControl(charge, index) {
                const container = document.getElementById('charges-container');
                
                const chargeControl = document.createElement('div');
                chargeControl.className = 'bg-gray-700 p-4 rounded-lg';
                chargeControl.id = `charge-control-${index}`;
                
                const sign = charge.q > 0 ? '+' : '-';
                
                chargeControl.innerHTML = `
                    <div class="flex justify-between items-center mb-3">
                        <div class="flex items-center">
                            <div class="w-4 h-4 rounded-full ${charge.q > 0 ? 'bg-positive glow-positive' : 'bg-negative glow-negative'} mr-2"></div>
                            <span>电荷 ${index + 1}</span>
                        </div>
                        <button class="delete-charge text-gray-400 hover:text-red-500" data-index="${index}">
                            <i class="fa fa-trash"></i>
                        </button>
                    </div>
                    
                    <div class="mb-3">
                        <label class="block text-gray-300 mb-1">电荷量 (q)</label>
                        <div class="flex items-center">
                            <input type="number" class="charge-q w-full bg-gray-600 border border-gray-500 rounded-lg px-3 py-1 text-white" 
                                   value="${Math.abs(charge.q)}" min="0.1" max="10" step="0.1" data-index="${index}">
                            <span class="ml-2 text-gray-400">× 10<sup>-6</sup> C</span>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-3 gap-2 mb-3">
                        <div>
                            <label class="block text-gray-300 text-xs mb-1">X</label>
                            <input type="number" class="charge-x bg-gray-600 border border-gray-500 rounded-lg px-2 py-1 text-white text-sm" 
                                   value="${charge.position.x}" min="-10" max="10" step="0.1" data-index="${index}">
                        </div>
                        <div>
                            <label class="block text-gray-300 text-xs mb-1">Y</label>
                            <input type="number" class="charge-y bg-gray-600 border border-gray-500 rounded-lg px-2 py-1 text-white text-sm" 
                                   value="${charge.position.y}" min="-10" max="10" step="0.1" data-index="${index}">
                        </div>
                        <div>
                            <label class="block text-gray-300 text-xs mb-1">Z</label>
                            <input type="number" class="charge-z bg-gray-600 border border-gray-500 rounded-lg px-2 py-1 text-white text-sm" 
                                   value="${charge.position.z}" min="-10" max="10" step="0.1" data-index="${index}">
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <label class="text-gray-300 text-sm">固定位置</label>
                        <div class="relative inline-block w-10 align-middle select-none">
                            <input type="checkbox" class="charge-fixed sr-only" data-index="${index}" ${charge.isFixed ? 'checked' : ''}>
                            <div class="block h-5 bg-gray-600 rounded-full w-10"></div>
                            <div class="dot absolute left-0.5 top-0.5 bg-white w-3.5 h-3.5 rounded-full transition-transform ${charge.isFixed ? 'translate-x-5' : ''}"></div>
                        </div>
                    </div>
                `;
                
                container.appendChild(chargeControl);
                
                // 添加事件监听器
                chargeControl.querySelector('.delete-charge').addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    removeCharge(index);
                });
                
                chargeControl.querySelector('.charge-q').addEventListener('input', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    const value = parseFloat(this.value);
                    const sign = charges[index].q > 0 ? 1 : -1;
                    charges[index].q = sign * value;
                    charges[index].magnitude = value.toFixed(1);
                    updateChargeDisplay(index);
                    calculateAndDrawFieldLines();
                });
                
                chargeControl.querySelector('.charge-x').addEventListener('input', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    const value = parseFloat(this.value);
                    charges[index].position.x = value;
                    charges[index].mesh.position.x = value;
                    calculateAndDrawFieldLines();
                });
                
                chargeControl.querySelector('.charge-y').addEventListener('input', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    const value = parseFloat(this.value);
                    charges[index].position.y = value;
                    charges[index].mesh.position.y = value;
                    calculateAndDrawFieldLines();
                });
                
                chargeControl.querySelector('.charge-z').addEventListener('input', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    const value = parseFloat(this.value);
                    charges[index].position.z = value;
                    charges[index].mesh.position.z = value;
                    calculateAndDrawFieldLines();
                });
                
                chargeControl.querySelector('.charge-fixed').addEventListener('change', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    charges[index].isFixed = this.checked;
                    
                    // 更新开关样式
                    const dot = this.nextElementSibling.nextElementSibling;
                    if (this.checked) {
                        dot.classList.add('translate-x-5');
                    } else {
                        dot.classList.remove('translate-x-5');
                    }
                });
            }
            
            // 更新电荷显示
            function updateChargeDisplay(index) {
                const charge = charges[index];
                const control = document.getElementById(`charge-control-${index}`);
                
                // 更新电荷符号和颜色
                const signElement = control.querySelector('.w-4.h-4');
                if (charge.q > 0) {
                    signElement.classList.remove('bg-negative', 'glow-negative');
                    signElement.classList.add('bg-positive', 'glow-positive');
                } else {
                    signElement.classList.remove('bg-positive', 'glow-positive');
                    signElement.classList.add('bg-negative', 'glow-negative');
                }
                
                // 更新电荷量
                const qInput = control.querySelector('.charge-q');
                qInput.value = Math.abs(charge.q);
            }
            
            // 移除电荷
            function removeCharge(index) {
                // 从场景中移除电荷网格
                scene.remove(charges[index].mesh);
                
                // 从电荷列表中移除
                charges.splice(index, 1);
                
                // 从控制面板中移除
                const control = document.getElementById(`charge-control-${index}`);
                if (control) {
                    control.remove();
                }
                
                // 更新剩余电荷的索引
                for (let i = index; i < charges.length; i++) {
                    const oldId = `charge-control-${i + 1}`;
                    const newId = `charge-control-${i}`;
                    const control = document.getElementById(oldId);
                    if (control) {
                        control.id = newId;
                        
                        // 更新电荷编号
                        const label = control.querySelector('span');
                        label.textContent = `电荷 ${i + 1}`;
                        
                        // 更新数据索引
                        const deleteBtn = control.querySelector('.delete-charge');
                        deleteBtn.setAttribute('data-index', i);
                        
                        const qInput = control.querySelector('.charge-q');
                        qInput.setAttribute('data-index', i);
                        
                        const xInput = control.querySelector('.charge-x');
                        xInput.setAttribute('data-index', i);
                        
                        const yInput = control.querySelector('.charge-y');
                        yInput.setAttribute('data-index', i);
                        
                        const zInput = control.querySelector('.charge-z');
                        zInput.setAttribute('data-index', i);
                        
                        const fixedInput = control.querySelector('.charge-fixed');
                        fixedInput.setAttribute('data-index', i);
                    }
                }
                
                // 重新计算电场线
                calculateAndDrawFieldLines();
            }
            
            // 计算给定点的电场强度
            function calculateElectricField(x, y, z) {
                let Ex = 0, Ey = 0, Ez = 0;
                
                for (const charge of charges) {
                    // 计算距离
                    const dx = x - charge.position.x;
                    const dy = y - charge.position.y;
                    const dz = z - charge.position.z;
                    const rSquared = dx * dx + dy * dy + dz * dz;
                    
                    // 避免除以零
                    if (rSquared < 0.01) continue;
                    
                    const r = Math.sqrt(rSquared);
                    const rCubed = r * r * r;
                    
                    // 计算电场强度 (F = k*q/r² * (r方向单位向量))
                    const kq = physicsParams.k * charge.q * 1e-6; // 电荷量转换为库仑
                    Ex += kq * dx / rCubed;
                    Ey += kq * dy / rCubed;
                    Ez += kq * dz / rCubed;
                }
                
                return new THREE.Vector3(Ex, Ey, Ez);
            }
            
            // 计算并绘制电场线 - 优化异种电荷间的电场线连接
            function calculateAndDrawFieldLines() {
                // 清除现现有的电场线
                clearFieldLines();
                
                // 如果没有电荷，直接返回
                if (charges.length === 0) return;
                
                // 分离正负电荷
                const positiveCharges = charges.filter(c => c.q > 0);
                const negativeCharges = charges.filter(c => c.q < 0);
                
                // 情况1：只有正电荷或只有负电荷
                if (positiveCharges.length === 0 || negativeCharges.length === 0) {
                    for (const charge of charges) {
                        // 生成电场线起始点
                        const startPoints = generateStartPoints(charge);
                        
                        // 为每个起始点生成电场线
                        for (const startPoint of startPoints) {
                            const linePoints = generateFieldLine(startPoint, charge.q > 0);
                            if (linePoints.length > 1) {
                                drawFieldLine(linePoints, charge.q > 0);
                            }
                        }
                    }
                } 
                // 情况2：同时有正负电荷，从正电荷出发到负电荷结束
                else {
                    // 计算每个电荷的电荷量比例
                    const totalPositiveCharge = positiveCharges.reduce((sum, c) => sum + c.q, 0);
                    const totalNegativeCharge = negativeCharges.reduce((sum, c) => sum + Math.abs(c.q), 0);
                    
                    // 确保总电荷量相等，否则按比例分配电场线
                    const chargeRatio = Math.min(totalPositiveCharge, totalNegativeCharge) / Math.max(totalPositiveCharge, totalNegativeCharge);
                    
                    // 从正电荷生成电场线
                    for (const positiveCharge of positiveCharges) {
                        // 根据电荷量确定电场线数量
                        const lineCount = Math.round(fieldLineParams.density * (positiveCharge.q / totalPositiveCharge));
                        
                        // 生成电场线起始点
                        const startPoints = generateStartPoints(positiveCharge, lineCount);
                        
                        // 为每个起始点生成电场线
                        for (const startPoint of startPoints) {
                            const linePoints = generateFieldLineToNegative(startPoint);
                            if (linePoints.length > 1) {
                                drawFieldLine(linePoints, true);
                            }
                        }
                    }
                    
                    // 如果负电荷总量大于正电荷，从负电荷生成额外的电场线（指向负电荷）
                    if (totalNegativeCharge > totalPositiveCharge) {
                        for (const negativeCharge of negativeCharges) {
                            const lineCount = Math.round(fieldLineParams.density * chargeRatio * (Math.abs(negativeCharge.q) / totalNegativeCharge));
                            const startPoints = generateStartPoints(negativeCharge, lineCount);
                            
                            for (const startPoint of startPoints) {
                                const linePoints = generateFieldLine(startPoint, false);
                                if (linePoints.length > 1) {
                                    drawFieldLine(linePoints, false);
                                }
                            }
                        }
                    }
                }
                
                // 更新显示选项
                updateDisplayOptions();
            }
            
            // 生成从正电荷到负电荷的电场线
            function generateFieldLineToNegative(startPoint) {
                const points = [startPoint.clone()];
                let currentPoint = startPoint.clone();
                
                // 前一个点的电场强度，用于平滑处理
                let prevE = null;
                
                // 找到最近的负电荷
                let nearestNegativeCharge = null;
                let minDistance = Infinity;
                for (const charge of charges) {
                    if (charge.q < 0) {
                        const distance = startPoint.distanceTo(charge.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestNegativeCharge = charge;
                        }
                    }
                }
                
                // 如果没有负电荷，返回空
                if (!nearestNegativeCharge) return [];
                
                for (let i = 0; i < fieldLineParams.length; i++) {
                    // 计算当前点的电场强度
                    const E = calculateElectricField(currentPoint.x, currentPoint.y, currentPoint.z);
                    
                    // 如果电场强度太小，停止生成
                    if (E.length() < 0.01) break;
                    
                    // 归一化
                    E.normalize();
                    
                    // 平滑处理：使用前一个点的电场方向进行插值
                    if (prevE && i > 0) {
                        // 插值系数，越靠近电荷越小，使线条更平滑
                        const t = Math.min(0.6, Math.max(0.2, i / 30));
                        E.lerp(prevE, t);
                        E.normalize();
                    }
                    
                    // 存储当前电场方向用于下一次平滑
                    prevE = E.clone();
                    
                    // 计算到最近负电荷的距离
                    const distanceToNegative = currentPoint.distanceTo(nearestNegativeCharge.position);
                    
                    // 根据距离电荷的远近调整步长，确保电场线能够平滑地终止于负电荷
                    let adaptiveStep = fieldLineParams.step;
                    
                    // 距离负电荷越近，步长越小
                    if (distanceToNegative < 2) {
                        adaptiveStep = fieldLineParams.step * (distanceToNegative / 2);
                    }
                    
                    // 当非常近负电荷时，进一步减小步长，确保平滑连接
                    if (distanceToNegative < 0.5) {
                        adaptiveStep = fieldLineParams.step * 0.1;
                    }
                    
                    // 计算下一个点
                    currentPoint.add(E.multiplyScalar(adaptiveStep));
                    
                    // 添加到点列表
                    points.push(currentPoint.clone());
                    
                    // 检查是否接近负电荷
                    if (distanceToNegative < 0.1) {
                        // 添加最后一个点，确保连接到负电荷
                        points.push(nearestNegativeCharge.position.clone());
                        break;
                    }
                    
                    // 检查是否超出边界
                    if (currentPoint.length() > 20) break;
                }
                
                // 如果电场线太短，不添加到场景
                if (points.length < 5) {
                    return [];
                }
                
                return points;
            }
            
            // 生成电场线起始点 - 均匀分布在球面上
            function generateStartPoints(charge, customDensity = null) {
                const points = [];
                const radius = 0.4; // 起始点距离电荷中心的距离
                const density = customDensity || fieldLineParams.density;
                
                // 根据电荷类型确定起始点分布
                if (Math.abs(charge.q) > 0) {
                    // 使用改进的斐波那契球面点分布算法，生成更加均匀分布的点
                    const goldenRatio = (1 + Math.sqrt(5)) / 2;
                    const angleIncrement = Math.PI * 2 / goldenRatio;
                    
                    for (let i = 0; i < density; i++) {
                        const t = i / density;
                        const inclination = Math.acos(1 - 2 * t);
                        const azimuth = angleIncrement * i;
                        
                        const x = Math.sin(inclination) * Math.cos(azimuth);
                        const y = Math.sin(inclination) * Math.sin(azimuth);
                        const z = Math.cos(inclination);
                        
                        // 转换为3D空间中的点
                        const point = new THREE.Vector3(
                            charge.position.x + x * radius,
                            charge.position.y + y * radius,
                            charge.position.z + z * radius
                        );
                        
                        points.push(point);
                    }
                }
                
                return points;
            }
            
            // 生成电场线 - 优化平滑度和分布
            function generateFieldLine(startPoint, isPositiveCharge) {
                const points = [startPoint.clone()];
                let currentPoint = startPoint.clone();
                
                // 步长因子，根据电荷类型确定方向
                const stepFactor = isPositiveCharge ? 1 : -1;
                
                // 前一个点的电场强度，用于平滑处理
                let prevE = null;
                
                for (let i = 0; i < fieldLineParams.length; i++) {
                    // 计算当前点的电场强度
                    const E = calculateElectricField(currentPoint.x, currentPoint.y, currentPoint.z);
                    
                    // 如果电场强度太小，停止生成
                    if (E.length() < 0.1) break;
                    
                    // 归一化并乘以步长
                    E.normalize();
                    
                    // 平滑处理：使用前一个点的电场方向进行插值
                    if (prevE && i > 0) {
                        // 插值系数，越靠近电荷越小，使线条更平滑
                        const t = Math.min(0.7, Math.max(0.3, i / 20));
                        E.lerp(prevE, t);
                        E.normalize();
                    }
                    
                    // 存储当前电场方向用于下一次平滑
                    prevE = E.clone();
                    
                    // 根据距离电荷的远近调整步长
                    let distanceToCharges = Infinity;
                    for (const charge of charges) {
                        const distance = currentPoint.distanceTo(charge.position);
                        distanceToCharges = Math.min(distanceToCharges, distance);
                    }
                    
                    // 距离电荷越近，步长越小，使线条更密集
                    let adaptiveStep = fieldLineParams.step;
                    if (distanceToCharges < 2) {
                        adaptiveStep = fieldLineParams.step * (distanceToCharges / 2);
                    }
                    
                    // 计算下一个点
                    currentPoint.add(E.multiplyScalar(adaptiveStep * stepFactor));
                    
                    // 检查是否接近其他电荷
                    let tooClose = false;
                    for (const charge of charges) {
                        const distance = currentPoint.distanceTo(charge.position);
                        if (distance < 0.4) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (tooClose) break;
                    
                    // 检查是否超出边界
                    if (currentPoint.length() > 20) break;
                    
                    // 添加到点列表
                    points.push(currentPoint.clone());
                }
                
                // 如果电场线太短，不添加到场景
                if (points.length < 5) {
                    return [];
                }
                
                return points;
            }
            
            // 绘制电场线 - 添加方向指示和渐变色
            function drawFieldLine(points, isPositiveCharge) {
                // 创建几何体
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // 创建颜色数组
                const colors = [];
                
                // 为电场线创建渐变色
                for (let i = 0; i < points.length; i++) {
                    // 计算颜色渐变因子 (0 到 1)
                    const t = i / (points.length - 1);
                    
                    // 正电荷电场线：从亮蓝到深蓝
                    // 负电荷电场线：从亮红到深红
                    if (isPositiveCharge) {
                        // 蓝色渐变
                        colors.push(0.2 + 0.4 * (1 - t), 0.5 + 0.3 * (1 - t), 1.0);
                    } else {
                        // 红色渐变
                        colors.push(1.0, 0.4 - 0.2 * (1 - t), 0.4 - 0.2 * (1 - t));
                    }
                }
                
                // 添加颜色属性
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                // 创建材质 - 使用渐变色
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    linewidth: 2
                });
                
                // 创建线对象
                const line = new THREE.Line(geometry, material);
                
                // 添加到场景
                scene.add(line);
                
                // 添加到电场线列表
                fieldLines.push(line);
                
                // 添加方向箭头
                addDirectionArrows(points, isPositiveCharge);
            }
            
            // 添加电场线方向箭头
            function addDirectionArrows(points, isPositiveCharge) {
                // 只在较长的电场线上添加箭头
                if (points.length < 20) return;
                
                // 箭头数量
                const arrowCount = Math.min(4, Math.floor(points.length / 6));
                
                // 箭头颜色
                const arrowColor = isPositiveCharge ? 0x93c5fd : 0xfca5a5;
                
                // 在电场线上均匀添加箭头
                for (let i = 1; i <= arrowCount; i++) {
                    const index = Math.floor(i * points.length / (arrowCount + 1));
                    
                    if (index > 0 && index < points.length - 1) {
                        const start = points[index - 1];
                        const end = points[index + 1];
                        
                        // 计算方向向量
                        const direction = new THREE.Vector3().subVectors(end, start).normalize();
                        
                        // 创建箭头材质
                        const arrowMaterial = new THREE.MeshBasicMaterial({ 
                            color: arrowColor,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        // 创建箭头
                        const arrow = new THREE.ArrowHelper(
                            direction,
                            points[index],
                            0.25,
                            arrowColor,
                            0.06,
                            0.04
                        );
                        
                        scene.add(arrow);
                        fieldLines.push(arrow);
                    }
                }
            }
            
            // 清除电场线
            function clearFieldLines() {
                for (const line of fieldLines) {
                    scene.remove(line);
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                    if (line.dispose) line.dispose();
                }
                fieldLines = [];
                
                // 清除矢量场
                clearVectorField();
            }
            
            // 清除矢量场
            function clearVectorField() {
                for (const vector of vectorField) {
                    scene.remove(vector);
                    vector.geometry.dispose();
                    vector.material.dispose();
                }
                vectorField = [];
            }
            
            // 创建电场强度热力图
            function createHeatmap() {
                // 清除现有的热力图
                if (heatmapMesh) {
                    scene.remove(heatmapMesh);
                    heatmapMesh.geometry.dispose();
                    heatmapMesh.material.dispose();
                }
                
                // 创建平面几何体
                const geometry = new THREE.PlaneGeometry(20, 20, 50, 50);
                
                // 创建材质
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                
                // 创建网格
                heatmapMesh = new THREE.Mesh(geometry, material);
                heatmapMesh.rotation.x = -Math.PI / 2;
                scene.add(heatmapMesh);
                
                // 更新热力图颜色
                updateHeatmapColors();
            }
            
            // 更新热力图颜色
            function updateHeatmapColors() {
                if (!heatmapMesh) return;
                
                const positions = heatmapMesh.geometry.attributes.position.array;
                const colors = new Float32Array(positions.length);
                
                // 计算最大电场强度用于归一化
                let maxFieldStrength = 0;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    const z = positions[i + 2];
                    
                    const E = calculateElectricField(x, y, z);
                    const strength = E.length();
                    
                    if (strength > maxFieldStrength) {
                        maxFieldStrength = strength;
                    }
                }
                
                // 归一化因子
                const normalizationFactor = maxFieldStrength > 0 ? 1 / maxFieldStrength : 1;
                
                // 更新颜色
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    const z = positions[i + 2];
                    
                    const E = calculateElectricField(x, y, z);
                    const strength = E.length() * normalizationFactor;
                    
                    // 使用热力图颜色映射 (蓝色-绿色-红色)
                    let r, g, b;
                    if (strength < 0.5) {
                        // 蓝色到绿色
                        const t = strength * 2;
                        r = 0;
                        g = t;
                        b = 1 - t;
                    } else {
                        // 绿色到红色
                        const t = (strength - 0.5) * 2;
                        r = t;
                        g = 1 - t;
                        b = 0;
                    }
                    
                    colors[i] = r;
                    colors[i + 1] = g;
                    colors[i + 2] = b;
                }
                
                // 添加颜色属性
                heatmapMesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                heatmapMesh.material.vertexColors = true;
            }
            
            // 创建电场强度矢量场
            function createVectorField() {
                // 清除现有的矢量场
                clearVectorField();
                
                // 创建网格点
                const gridSize = 10;
                const spacing = 2;
                
                for (let x = -gridSize; x <= gridSize; x += spacing) {
                    for (let y = -gridSize; y <= gridSize; y += spacing) {
                        for (let z = -gridSize; z <= gridSize; z += spacing) {
                            // 检查是否太靠近电荷
                            let tooClose = false;
                            for (const charge of charges) {
                                const distance = new THREE.Vector3(x, y, z).distanceTo(charge.position);
                                if (distance < 0.8) {
                                    tooClose = true;
                                    break;
                                }
                            }
                            
                            if (tooClose) continue;
                            
                            // 计算电场强度
                            const E = calculateElectricField(x, y, z);
                            const strength = E.length();
                            
                            // 如果电场强度太小，跳过
                            if (strength < 0.1) continue;
                            
                            // 归一化并缩放
                            E.normalize().multiplyScalar(0.5);
                            
                            // 创建箭头
                            const arrowDir = E.clone();
                            const arrowOrigin = new THREE.Vector3(x, y, z);
                            const arrowLength = 0.5;
                            const arrowColor = 0xffff00;
                            
                            const arrow = new THREE.ArrowHelper(arrowDir, arrowOrigin, arrowLength, arrowColor, 0.1, 0.05);
                            scene.add(arrow);
                            
                            // 添加到矢量场列表
                            vectorField.push(arrow);
                        }
                    }
                }
            }
            
            // 初始化控制面板
            function initControlPanel() {
                // 预设场景按钮
                document.getElementById('preset-single-positive').addEventListener('click', function() {
                    console.log('Single positive charge preset clicked');
                    clearAllCharges();
                    setTimeout(() => {
                        addCharge(0, 0, 0, 1);
                        setTimeout(() => {
                            calculateAndDrawFieldLines();
                        }, 100);
                    }, 100);
                });
                
                document.getElementById('preset-single-negative').addEventListener('click', function() {
                    console.log('Single negative charge preset clicked');
                    clearAllCharges();
                    setTimeout(() => {
                        addCharge(0, 0, 0, -1);
                        setTimeout(() => {
                            calculateAndDrawFieldLines();
                        }, 100);
                    }, 100);
                });
                
                document.getElementById('preset-dipole').addEventListener('click', function() {
                    console.log('Dipole preset clicked');
                    clearAllCharges();
                    setTimeout(() => {
                        addCharge(-2, 0, 0, 1, true);
                        addCharge(2, 0, 0, -1, true);
                        setTimeout(() => {
                            calculateAndDrawFieldLines();
                        }, 100);
                    }, 100);
                });
                
                document.getElementById('preset-same-charges').addEventListener('click', function() {
                    console.log('Same charges preset clicked');
                    clearAllCharges();
                    setTimeout(() => {
                        addCharge(-2, 0, 0, 1, true);
                        addCharge(2, 0, 0, 1, true);
                        setTimeout(() => {
                            calculateAndDrawFieldLines();
                        }, 100);
                    }, 100);
                });
                
                document.getElementById('preset-three-charges').addEventListener('click', function() {
                    console.log('Three charges preset clicked');
                    clearAllCharges();
                    setTimeout(() => {
                        addCharge(-3, 0, 0, 1, true);
                        addCharge(0, 0, 0, -1, true);
                        addCharge(3, 0, 0, 1, true);
                        setTimeout(() => {
                            calculateAndDrawFieldLines();
                        }, 100);
                    }, 100);
                });
                
                // 添加电荷按钮
                document.getElementById('add-charge').addEventListener('click', function() {
                    // 找到一个合适的位置添加新电荷
                    let x = (Math.random() - 0.5) * 10;
                    let y = (Math.random() - 0.5) * 10;
                    let z = (Math.random() - 0.5) * 10;
                    
                    // 确保新电荷不会太靠近现有电荷
                    for (const charge of charges) {
                        const distance = new THREE.Vector3(x, y, z).distanceTo(charge.position);
                        if (distance < 1.5) {
                            // 重新生成位置
                            x = (Math.random() - 0.5) * 10;
                            y = (Math.random() - 0.5) * 10;
                            z = (Math.random() - 0.5) * 10;
                            break;
                        }
                    }
                    
                    // 添加新电荷
                    addCharge(x, y, z, 1);
                    calculateAndDrawFieldLines();
                });
                
                // 显示选项开关
                document.getElementById('show-field-lines').addEventListener('change', function() {
                    displayOptions.fieldLines = this.checked;
                    
                    // 更新开关样式
                    const dot = this.nextElementSibling.nextElementSibling;
                    if (this.checked) {
                        dot.classList.add('translate-x-6');
                    } else {
                        dot.classList.remove('translate-x-6');
                    }
                    
                    updateDisplayOptions();
                });
                
                document.getElementById('show-heatmap').addEventListener('change', function() {
                    displayOptions.heatmap = this.checked;
                    
                    // 更新开关样式
                    const dot = this.nextElementSibling.nextElementSibling;
                    if (this.checked) {
                        dot.classList.add('translate-x-6');
                        createHeatmap();
                    } else {
                        dot.classList.remove('translate-x-6');
                        if (heatmapMesh) {
                            scene.remove(heatmapMesh);
                        }
                    }
                    
                    updateDisplayOptions();
                });
                
                document.getElementById('show-vectors').addEventListener('change', function() {
                    displayOptions.vectors = this.checked;
                    
                    // 更新开关样式
                    const dot = this.nextElementSibling.nextElementSibling;
                    if (this.checked) {
                        dot.classList.add('translate-x-6');
                        createVectorField();
                    } else {
                        dot.classList.remove('translate-x-6');
                        clearVectorField();
                    }
                    
                    updateDisplayOptions();
                });
                
                document.getElementById('show-grid').addEventListener('change', function() {
                    displayOptions.grid = this.checked;
                    
                    // 更新开关样式
                    const dot = this.nextElementSibling.nextElementSibling;
                    if (this.checked) {
                        dot.classList.add('translate-x-6');
                        if (gridHelper) scene.add(gridHelper);
                        if (axesHelper) scene.add(axesHelper);
                    } else {
                        dot.classList.remove('translate-x-6');
                        if (gridHelper) scene.remove(gridHelper);
                        if (axesHelper) scene.remove(axesHelper);
                    }
                    
                    updateDisplayOptions();
                });
                
                // 电场线参数滑块
                document.getElementById('field-line-density').addEventListener('input', function() {
                    fieldLineParams.density = parseInt(this.value);
                    document.getElementById('density-value').textContent = this.value;
                    calculateAndDrawFieldLines();
                });
                
                document.getElementById('field-line-length').addEventListener('input', function() {
                    fieldLineParams.length = parseInt(this.value);
                    document.getElementById('length-value').textContent = this.value;
                    calculateAndDrawFieldLines();
                });
                
                document.getElementById('field-line-step').addEventListener('input', function() {
                    fieldLineParams.step = parseFloat(this.value);
                    document.getElementById('step-value').textContent = this.value;
                    calculateAndDrawFieldLines();
                });
                
                // 物理参数
                document.getElementById('coulomb-constant').addEventListener('input', function() {
                    physicsParams.k = parseFloat(this.value) * 1e9;
                    calculateAndDrawFieldLines();
                    
                    // 如果显示热力图或矢量场，也需要更新
                    if (displayOptions.heatmap && heatmapMesh) {
                        updateHeatmapColors();
                    }
                    
                    if (displayOptions.vectors) {
                        createVectorField();
                    }
                });
                
                // 重置视图按钮
                document.getElementById('reset-view').addEventListener('click', function() {
                    controls.reset();
                });
            }
            
            // 清除所有电荷
            function clearAllCharges() {
                // 清除电场线
                clearFieldLines();
                
                // 清除热力图
                if (heatmapMesh) {
                    scene.remove(heatmapMesh);
                    heatmapMesh = null;
                }
                
                // 清除电荷
                for (const charge of charges) {
                    scene.remove(charge.mesh);
                }
                charges = [];
                
                // 清除控制面板中的电荷控制
                document.getElementById('charges-container').innerHTML = '';
            }
            
            // 更新显示选项
            function updateDisplayOptions() {
                // 更新电场线显示
                for (const line of fieldLines) {
                    line.visible = displayOptions.fieldLines;
                }
                
                // 更新网格和坐标轴显示
                if (gridHelper) gridHelper.visible = displayOptions.grid;
                if (axesHelper) axesHelper.visible = displayOptions.grid;
                
                // 更新热力图显示
                if (heatmapMesh) {
                    heatmapMesh.visible = displayOptions.heatmap;
                }
                
                // 更新矢量场显示
                for (const vector of vectorField) {
                    vector.visible = displayOptions.vectors;
                }
            }
            
            // 初始化应用
            init();
        }
        
        // ===== 电磁感应实验 =====
        function initInductionExperiment() {
            console.log('Initializing induction experiment...');
            
            // 全局变量
            const canvas = document.getElementById('experimentCanvas');
            const ctx = canvas.getContext('2d');
            let animationId = null;
            let isPlaying = false;
            let experimentType = 'basic';
            
            // 物理参数
            let coilTurns = 50;
            let magnetStrength = 1.0;
            let coilResistance = 10.0;
            
            // 磁铁状态
            const magnet = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: 80,
                height: 20,
                isDragging: false,
                lastX: 0,
                lastY: 0,
                northColor: '#e11d48', // 深红色
                southColor: '#2563eb', // 蓝色
            };
            
            // 线圈状态
            const coil = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 100,
                width: 20,
                turns: coilTurns,
                resistance: coilResistance,
            };
            
            // 数据记录
            const dataRecords = {
                time: [],
                current: [],
                emf: [],
                flux: [],
                fluxRate: [],
                maxPoints: 100,
            };
            
            // 电流图表
            const currentChartCtx = document.getElementById('currentChart').getContext('2d');
            const currentChart = new Chart(currentChartCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '感应电流 (A)',
                        data: [],
                        borderColor: '#1E40AF',
                        backgroundColor: 'rgba(30, 64, 175, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '时间 (s)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '电流 (A)'
                            }
                        }
                    },
                    animation: {
                        duration: 0
                    }
                }
            });
            
            // 初始化Canvas尺寸
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                // 更新磁铁和线圈位置
                magnet.x = canvas.width / 2;
                magnet.y = canvas.height / 2;
                coil.x = canvas.width / 2;
                coil.y = canvas.height / 2;
            }
            
            // 初始化
            function init() {
                resizeCanvas();
                setupEventListeners();
                resetExperiment();
                drawExperiment();
            }
            
            // 设置事件监听器
            function setupEventListeners() {
                // 窗口大小改变时调整Canvas尺寸
                window.addEventListener('resize', resizeCanvas);
                
                // 磁铁拖拽
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
                canvas.addEventListener('mouseleave', handleMouseUp);
                
                // 触摸设备支持
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd);
                
                // 控制按钮
                document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
                document.getElementById('resetBtn').addEventListener('click', resetExperiment);
                
                // 实验类型选择
                document.getElementById('experimentType').addEventListener('change', function() {
                    experimentType = this.value;
                    resetExperiment();
                });
                
                // 参数控制
                document.getElementById('coilTurns').addEventListener('input', function() {
                    coilTurns = parseInt(this.value);
                    coil.turns = coilTurns;
                    document.getElementById('coilTurnsValue').textContent = coilTurns + '匝';
                    updateCalculations();
                });
                
                document.getElementById('magnetStrength').addEventListener('input', function() {
                    magnetStrength = parseFloat(this.value);
                    const strengthText = magnetStrength < 0.7 ? '弱' : (magnetStrength < 1.4 ? '中等' : '强');
                    document.getElementById('magnetStrengthValue').textContent = strengthText;
                    updateCalculations();
                });
                
                document.getElementById('coilResistance').addEventListener('input', function() {
                    coilResistance = parseFloat(this.value);
                    coil.resistance = coilResistance;
                    document.getElementById('coilResistanceValue').textContent = coilResistance + 'Ω';
                    updateCalculations();
                });
            }
            
            // 鼠标按下事件处理
            function handleMouseDown(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // 检查是否点击在磁铁上
                if (mouseX >= magnet.x - magnet.width / 2 && 
                    mouseX <= magnet.x + magnet.width / 2 && 
                    mouseY >= magnet.y - magnet.height / 2 && 
                    mouseY <= magnet.y + magnet.height / 2) {
                    magnet.isDragging = true;
                    magnet.lastX = mouseX;
                    magnet.lastY = mouseY;
                    canvas.style.cursor = 'grabbing';
                }
            }
            
            // 鼠标移动事件处理
            function handleMouseMove(e) {
                if (!magnet.isDragging) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // 计算移动距离
                const dx = mouseX - magnet.lastX;
                const dy = mouseY - magnet.lastY;
                
                // 更新磁铁位置
                magnet.x += dx;
                magnet.y += dy;
                
                // 限制磁铁在Canvas内
                magnet.x = Math.max(magnet.width / 2, Math.min(canvas.width - magnet.width / 2, magnet.x));
                magnet.y = Math.max(magnet.height / 2, Math.min(canvas.height - magnet.height / 2, magnet.y));
                
                // 更新上一次位置
                magnet.lastX = mouseX;
                magnet.lastY = mouseY;
                
                // 更新计算
                updateCalculations();
                
                // 重绘
                drawExperiment();
            }
            
            // 鼠标释放事件处理
            function handleMouseUp() {
                if (magnet.isDragging) {
                    magnet.isDragging = false;
                    canvas.style.cursor = 'default';
                }
            }
            
            // 触摸开始事件处理
            function handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    handleMouseDown(mouseEvent);
                }
            }
            
            // 触摸移动事件处理
            function handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    handleMouseMove(mouseEvent);
                }
            }
            
            // 触摸结束事件处理
            function handleTouchEnd(e) {
                handleMouseUp();
            }
            
            // 切换播放/暂停
            function togglePlayPause() {
                isPlaying = !isPlaying;
                const playPauseBtn = document.getElementById('playPauseBtn');
                
                if (isPlaying) {
                    playPauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i> 暂停';
                    startAnimation();
                } else {
                    playPauseBtn.innerHTML = '<i class="fa fa-play mr-1"></i> 播放';
                    stopAnimation();
                }
            }
            
            // 开始动画
            function startAnimation() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                
                let lastTime = 0;
                
                function animate(timestamp) {
                    if (!lastTime) lastTime = timestamp;
                    const deltaTime = (timestamp - lastTime) / 1000; // 转换为秒
                    lastTime = timestamp;
                    
                    // 更新磁铁位置（自动动画）
                    if (experimentType === 'basic' && isPlaying) {
                        // 简单的来回运动
                        magnet.x = coil.x + Math.sin(timestamp / 1000) * 150;
                    }
                    
                    // 更新计算
                    updateCalculations();
                    
                    // 重绘
                    drawExperiment();
                    
                    // 继续动画
                    animationId = requestAnimationFrame(animate);
                }
                
                animationId = requestAnimationFrame(animate);
            }
            
            // 停止动画
            function stopAnimation() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            
            // 重置实验
            function resetExperiment() {
                // 停止动画
                isPlaying = false;
                document.getElementById('playPauseBtn').innerHTML = '<i class="fa fa-play mr-1"></i> 播放';
                stopAnimation();
                
                // 重置磁铁位置
                magnet.x = canvas.width / 2 - 150;
                magnet.y = canvas.height / 2;
                
                // 重置数据记录
                dataRecords.time = [];
                dataRecords.current = [];
                dataRecords.emf = [];
                dataRecords.flux = [];
                dataRecords.fluxRate = [];
                
                // 更新图表
                updateChart();
                
                // 更新计算
                updateCalculations();
                
                // 重绘
                drawExperiment();
            }
            
            // 更新计算
            function updateCalculations() {
                // 计算磁铁和线圈之间的距离
                const dx = magnet.x - coil.x;
                const dy = magnet.y - coil.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 计算磁通量（简化模型）
                // 磁通量随距离的平方反比衰减，并与磁铁强度成正比
                const maxDistance = canvas.width;
                const normalizedDistance = Math.min(distance / maxDistance, 1);
                const flux = magnetStrength * coil.turns * Math.exp(-normalizedDistance * 10) * 0.01;
                
                // 计算磁通量变化率（基于磁铁位置的变化）
                // 使用数值微分法
                let fluxRate = 0;
                if (dataRecords.flux.length > 0) {
                    const lastFlux = dataRecords.flux[dataRecords.flux.length - 1];
                    const timeDiff = dataRecords.time.length > 0 ? 
                        (Date.now() - dataRecords.time[dataRecords.time.length - 1]) / 1000 : 0.016; // 约60fps
                    
                    if (timeDiff > 0) {
                        fluxRate = (flux - lastFlux) / timeDiff;
                    }
                }
                
                // 计算感应电动势（法拉第定律）
                const emf = -fluxRate;
                
                // 计算感应电流（欧姆定律）
                const current = emf / coil.resistance;
                
                // 记录数据
                const now = Date.now();
                dataRecords.time.push(now);
                dataRecords.current.push(current);
                dataRecords.emf.push(emf);
                dataRecords.flux.push(flux);
                dataRecords.fluxRate.push(fluxRate);
                
                // 限制数据点数量
                if (dataRecords.time.length > dataRecords.maxPoints) {
                    dataRecords.time.shift();
                    dataRecords.current.shift();
                    dataRecords.emf.shift();
                    dataRecords.flux.shift();
                    dataRecords.fluxRate.shift();
                }
                
                // 更新显示
                document.getElementById('emfValue').textContent = Math.abs(emf).toFixed(2);
                document.getElementById('currentValue').textContent = Math.abs(current).toFixed(2);
                document.getElementById('fluxValue').textContent = flux.toFixed(4);
                document.getElementById('fluxRateValue').textContent = fluxRate.toFixed(4);
                
                // 更新图表
                updateChart();
            }
            
            // 更新图表
            function updateChart() {
                // 转换时间格式
                const labels = dataRecords.time.map(time => {
                    const date = new Date(time);
                    return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                });
                
                // 更新图表数据
                currentChart.data.labels = labels;
                currentChart.data.datasets[0].data = dataRecords.current;
                currentChart.update();
            }
            
            // 绘制实验
            function drawExperiment() {
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制背景网格
                drawGrid();
                
                // 根据实验类型绘制不同内容
                if (experimentType === 'microscopic') {
                    drawMicroscopicView();
                } else {
                    // 绘制线圈
                    drawCoil();
                    
                    // 绘制磁铁
                    drawMagnet();
                    
                    // 绘制磁场线
                    drawMagneticField();
                    
                    // 绘制感应电流
                    drawCurrentIndicator();
                }
            }
            
            // 绘制背景网格
            function drawGrid() {
                const gridSize = 20;
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 1;
                
                // 绘制垂直线
                for (let x = 0; x <= canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // 绘制水平线
                for (let y = 0; y <= canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // 绘制线圈
            function drawCoil() {
                // 绘制线圈外圈
                ctx.beginPath();
                ctx.arc(coil.x, coil.y, coil.radius, 0, Math.PI * 2);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = coil.width;
                ctx.stroke();
                
                // 绘制线圈内部线条（表示多匝）
                const turnSpacing = coil.width / (coil.turns / 10); // 每10匝绘制一条线
                for (let i = 1; i < 10; i++) {
                    const radius = coil.radius - i * turnSpacing;
                    ctx.beginPath();
                    ctx.arc(coil.x, coil.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#64748b';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // 绘制线圈连接线
                ctx.beginPath();
                ctx.moveTo(coil.x, coil.y - coil.radius);
                ctx.lineTo(coil.x, coil.y - coil.radius - 20);
                ctx.lineTo(coil.x + 100, coil.y - coil.radius - 20);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(coil.x, coil.y + coil.radius);
                ctx.lineTo(coil.x, coil.y + coil.radius + 20);
                ctx.lineTo(coil.x + 100, coil.y + coil.radius + 20);
                ctx.stroke();
                
                // 绘制电阻
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(coil.x + 100, coil.y - 15, 40, 30);
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${coil.resistance}Ω`, coil.x + 120, coil.y);
                
                // 绘制电流表
                ctx.beginPath();
                ctx.arc(coil.x + 180, coil.y, 30, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制电流表指针
                const current = parseFloat(document.getElementById('currentValue').textContent);
                const maxCurrent = 0.1;
                const needleAngle = -Math.PI / 4 + (current / maxCurrent) * Math.PI / 2;
                
                ctx.beginPath();
                ctx.moveTo(coil.x + 180, coil.y);
                ctx.lineTo(
                    coil.x + 180 + Math.cos(needleAngle) * 25,
                    coil.y + Math.sin(needleAngle) * 25
                );
                ctx.strokeStyle = '#e11d48';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制电流表刻度
                ctx.beginPath();
                ctx.arc(coil.x + 180, coil.y, 25, -Math.PI / 4, Math.PI / 4);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // 绘制电流表标签
                ctx.fillStyle = '#000000';
                ctx.font = '10px Arial';
                ctx.fillText('A', coil.x + 180, coil.y + 5);
            }
            
            // 绘制磁铁
            function drawMagnet() {
                // 绘制磁铁主体
                ctx.save();
                ctx.translate(magnet.x, magnet.y);
                
                // 绘制磁铁轮廓
                ctx.beginPath();
                ctx.roundRect(-magnet.width / 2, -magnet.height / 2, magnet.width, magnet.height, 5);
                ctx.fillStyle = '#f3f4f6';
                ctx.fill();
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制磁铁N极
                const poleWidth = magnet.width / 2;
                ctx.beginPath();
                ctx.roundRect(-magnet.width / 2, -magnet.height / 2, poleWidth, magnet.height, [5, 0, 0, 5]);
                ctx.fillStyle = magnet.northColor;
                ctx.fill();
                
                // 绘制磁铁S极
                ctx.beginPath();
                ctx.roundRect(0, -magnet.height / 2, poleWidth, magnet.height, [0, 5, 5, 0]);
                ctx.fillStyle = magnet.southColor;
                ctx.fill();
                
                // 绘制磁极标签
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('N', -poleWidth / 2, 0);
                ctx.fillText('S', poleWidth / 2, 0);
                
                ctx.restore();
            }
            
            // 绘制磁场线
            function drawMagneticField() {
                // 计算磁铁和线圈之间的距离
                const dx = magnet.x - coil.x;
                const dy = magnet.y - coil.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 磁场强度随距离衰减
                const fieldStrength = magnetStrength * Math.exp(-distance / 200);
                
                // 绘制从N极到S极的磁场线
                const numLines = 8;
                const lineSpacing = magnet.height / (numLines + 1);
                
                for (let i = 1; i <= numLines; i++) {
                    const startY = magnet.y - magnet.height / 2 + i * lineSpacing;
                    
                    // 起点（N极）
                    const startX = magnet.x - magnet.width / 2;
                    
                    // 终点（S极）
                    const endX = magnet.x + magnet.width / 2;
                    const endY = startY;
                    
                    // 绘制弯曲的磁场线
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    // 控制点，使磁场线弯曲
                    const controlDistance = distance / 3;
                    const controlX1 = startX + controlDistance;
                    const controlX2 = endX - controlDistance;
                    
                    // 根据磁铁和线圈的相对位置调整控制点Y坐标
                    const coilInfluence = Math.min(1, Math.max(0, 1 - distance / 300));
                    const controlY1 = startY - coilInfluence * 50;
                    const controlY2 = endY + coilInfluence * 50;
                    
                    ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
                    
                    // 根据磁场强度调整线条样式
                    const lineOpacity = fieldStrength * (numLines - i + 1) / numLines;
                    ctx.strokeStyle = `rgba(30, 64, 175, ${lineOpacity})`;
                    ctx.lineWidth = 1 + fieldStrength;
                    ctx.stroke();
                    
                    // 绘制箭头
                    const arrowX = startX + (endX - startX) * 0.7;
                    const arrowY = startY + (endY - startY) * 0.7 + (controlY2 - controlY1) * 0.3;
                    
                    // 计算箭头方向
                    const angle = Math.atan2(endY - startY, endX - startX);
                    
                    ctx.save();
                    ctx.translate(arrowX, arrowY);
                    ctx.rotate(angle);
                    
                    // 绘制箭头
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-5, -3);
                    ctx.lineTo(-5, 3);
                    ctx.closePath();
                    ctx.fillStyle = `rgba(30, 64, 175, ${lineOpacity})`;
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // 如果磁铁靠近线圈，绘制穿过线圈的磁场线
                if (distance < coil.radius + 50) {
                    drawFieldLinesThroughCoil(fieldStrength);
                }
            }
            
            // 绘制穿过线圈的磁场线
            function drawFieldLinesThroughCoil(fieldStrength) {
                const numLines = 12;
                const angleStep = (Math.PI * 2) / numLines;
                
                for (let i = 0; i < numLines; i++) {
                    const angle = i * angleStep;
                    const x = coil.x + Math.cos(angle) * coil.radius;
                    const y = coil.y + Math.sin(angle) * coil.radius;
                    
                    // 检查该点是否在磁铁的磁场范围内
                    const dx = x - magnet.x;
                    const dy = y - magnet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 200) {
                        // 绘制穿过线圈的磁场线
                        ctx.beginPath();
                        
                        // 从线圈外部到内部
                        const startX = coil.x + Math.cos(angle) * (coil.radius + 30);
                        const startY = coil.y + Math.sin(angle) * (coil.radius + 30);
                        const endX = coil.x + Math.cos(angle) * (coil.radius - 30);
                        const endY = coil.y + Math.sin(angle) * (coil.radius - 30);
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        
                        // 根据磁场强度和距离调整线条样式
                        const lineOpacity = fieldStrength * Math.exp(-distance / 200);
                        ctx.strokeStyle = `rgba(30, 64, 175, ${lineOpacity})`;
                        ctx.lineWidth = 1 + fieldStrength * 2;
                        ctx.stroke();
                        
                        // 绘制箭头
                        const arrowX = startX + (endX - startX) * 0.5;
                        const arrowY = startY + (endY - startY) * 0.5;
                        
                        ctx.save();
                        ctx.translate(arrowX, arrowY);
                        ctx.rotate(angle);
                        
                        // 绘制箭头
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-5, -3);
                        ctx.lineTo(-5, 3);
                        ctx.closePath();
                        ctx.fillStyle = `rgba(30, 64, 175, ${lineOpacity})`;
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
            }
            
            // 绘制感应电流指示器
            function drawCurrentIndicator() {
                const current = parseFloat(document.getElementById('currentValue').textContent);
                const emf = parseFloat(document.getElementById('emfValue').textContent);
                
                // 如果电流太小，不显示指示器
                if (current < 0.01) return;
                
                // 电流方向（根据楞次定律）
                // 当磁铁靠近线圈时，感应电流产生的磁场方向与外磁场相反
                // 当磁铁远离线圈时，感应电流产生的磁场方向与外磁场相同
                
                // 计算磁铁和线圈之间的距离
                const dx = magnet.x - coil.x;
                const distance = Math.abs(dx);
                
                // 计算磁铁移动速度（基于位置变化）
                let velocity = 0;
                if (dataRecords.time.length > 1) {
                    const lastTime = dataRecords.time[dataRecords.time.length - 2];
                    const lastX = dataRecords.time.length > 2 ? 
                        (dataRecords.flux[dataRecords.flux.length - 2] - dataRecords.flux[dataRecords.flux.length - 3]) : 0;
                    const timeDiff = (Date.now() - lastTime) / 1000;
                    
                    if (timeDiff > 0) {
                        velocity = lastX / timeDiff;
                    }
                }
                
                // 确定电流方向
                const clockwise = velocity > 0;
                
                // 绘制电流指示器（箭头）
                const numArrows = Math.min(8, Math.max(2, Math.floor(current * 100)));
                const angleStep = (Math.PI * 2) / numArrows;
                
                for (let i = 0; i < numArrows; i++) {
                    const angle = i * angleStep + (clockwise ? 0 : Math.PI);
                    const x = coil.x + Math.cos(angle) * coil.radius;
                    const y = coil.y + Math.sin(angle) * coil.radius;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + (clockwise ? Math.PI / 2 : -Math.PI / 2));
                    
                    // 绘制箭头
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(5, 0);
                    ctx.lineTo(-5, 0);
                    ctx.closePath();
                    
                    // 根据电流大小调整颜色
                    const intensity = Math.min(1, current * 10);
                    ctx.fillStyle = `rgba(255, 107, 0, ${intensity})`;
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // 绘制电流方向标签
                ctx.fillStyle = '#000000';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    clockwise ? '顺时针' : '逆时针',
                    coil.x,
                    coil.y - coil.radius - 30
                );
                
                // 绘制感应电动势方向
                ctx.fillText(
                    `感应电动势: ${emf.toFixed(2)}V`,
                    coil.x,
                    coil.y + coil.radius + 30
                );
            }
            
            // 绘制微观粒子视图
            function drawMicroscopicView() {
                // 绘制线圈横截面
                ctx.beginPath();
                ctx.arc(coil.x, coil.y, coil.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 116, 139, 0.1)';
                ctx.fill();
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制磁铁（简化为条形）
                ctx.beginPath();
                ctx.roundRect(
                    magnet.x - magnet.width / 2,
                    magnet.y - magnet.height / 2,
                    magnet.width,
                    magnet.height,
                    5
                );
                ctx.fillStyle = '#f3f4f6';
                ctx.fill();
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制磁极
                const poleWidth = magnet.width / 2;
                ctx.beginPath();
                ctx.roundRect(
                    magnet.x - magnet.width / 2,
                    magnet.y - magnet.height / 2,
                    poleWidth,
                    magnet.height,
                    [5, 0, 0, 5]
                );
                ctx.fillStyle = magnet.northColor;
                ctx.fill();
                
                ctx.beginPath();
                ctx.roundRect(
                    magnet.x,
                    magnet.y - magnet.height / 2,
                    poleWidth,
                    magnet.height,
                    [0, 5, 5, 0]
                );
                ctx.fillStyle = magnet.southColor;
                ctx.fill();
                
                // 绘制磁极标签
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('N', magnet.x - poleWidth / 2, magnet.y);
                ctx.fillText('S', magnet.x + poleWidth / 2, magnet.y);
                
                // 计算感应电流
                const current = parseFloat(document.getElementById('currentValue').textContent);
                
                // 如果电流太小，不显示电子
                if (current < 0.01) {
                    ctx.fillStyle = '#000000';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('无明显感应电流', coil.x, coil.y);
                    return;
                }
                
                // 绘制电子
                const numElectrons = Math.min(50, Math.max(5, Math.floor(current * 500)));
                
                // 计算磁铁和线圈之间的距离
                const dx = magnet.x - coil.x;
                const distance = Math.abs(dx);
                
                // 确定电流方向
                const clockwise = dx > 0;
                
                // 绘制电子
                for (let i = 0; i < numElectrons; i++) {
                    const angle = (i / numElectrons) * Math.PI * 2;
                    const x = coil.x + Math.cos(angle) * coil.radius;
                    const y = coil.y + Math.sin(angle) * coil.radius;
                    
                    // 添加一些随机偏移，使电子分布更自然
                    const offset = (Math.random() - 0.5) * 10;
                    const electronX = x + Math.cos(angle) * offset;
                    const electronY = y + Math.sin(angle) * offset;
                    
                    // 绘制电子
                    ctx.beginPath();
                    ctx.arc(electronX, electronY, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff6b00';
                    ctx.fill();
                    
                    // 绘制电子运动方向指示器
                    const directionAngle = clockwise ? angle + Math.PI / 2 : angle - Math.PI / 2;
                    const arrowLength = 5;
                    
                    ctx.beginPath();
                    ctx.moveTo(electronX, electronY);
                    ctx.lineTo(
                        electronX + Math.cos(directionAngle) * arrowLength,
                        electronY + Math.sin(directionAngle) * arrowLength
                    );
                    ctx.strokeStyle = '#ff6b00';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // 绘制说明文字
                ctx.fillStyle = '#000000';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    `电子运动方向: ${clockwise ? '顺时针' : '逆时针'}`,
                    coil.x,
                    coil.y - coil.radius - 30
                );
                
                ctx.font = '14px Arial';
                ctx.fillText(
                    '电子在导体中运动形成感应电流',
                    coil.x,
                    coil.y + coil.radius + 30
                );
                
                // 绘制磁场线（简化）
                drawMicroscopicMagneticField();
            }
            
            // 绘制微观视图中的磁场线
            function drawMicroscopicMagneticField() {
                // 绘制从N极到S极的磁场线
                const numLines = 5;
                const lineSpacing = magnet.height / (numLines + 1);
                
                for (let i = 1; i <= numLines; i++) {
                    const startY = magnet.y - magnet.height / 2 + i * lineSpacing;
                    
                    // 起点（N极）
                    const startX = magnet.x - magnet.width / 2;
                    
                    // 终点（S极）
                    const endX = magnet.x + magnet.width / 2;
                    const endY = startY;
                    
                    // 绘制弯曲的磁场线
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    // 控制点，使磁场线弯曲
                    const controlDistance = 100;
                    const controlX1 = startX + controlDistance;
                    const controlX2 = endX - controlDistance;
                    
                    ctx.bezierCurveTo(controlX1, startY - 50, controlX2, endY + 50, endX, endY);
                    
                    ctx.strokeStyle = 'rgba(30, 64, 175, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 绘制箭头
                    const arrowX = startX + (endX - startX) * 0.7;
                    const arrowY = startY + (endY - startY) * 0.7 - 20;
                    
                    // 计算箭头方向
                    const angle = Math.atan2(endY - startY + 100, endX - startX);
                    
                    ctx.save();
                    ctx.translate(arrowX, arrowY);
                    ctx.rotate(angle);
                    
                    // 绘制箭头
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-5, -3);
                    ctx.lineTo(-5, 3);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(30, 64, 175, 0.6)';
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // 绘制磁场方向说明
                ctx.fillStyle = '#000000';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    '磁场方向: 从N极到S极',
                    magnet.x,
                    magnet.y - magnet.height / 2 - 20
                );
            }
            
            // 初始化
            init();
        }
        
        // 初始化页面
        window.addEventListener('load', function() {
            // 默认显示首页
            showPage('home');
        });
    </script>
</body>
</html>